import { Signer } from '@ethersproject/abstract-signer';
import { splitSignature } from '@ethersproject/bytes';
import * as legacy from './legacy/crypto';
import * as compatible from './backwards-compatible/crypto';
import { createStarkSigner } from './starkSigner';

/**
 * Generates a new Stark private key
 * @returns the private key as a hex string
 */
export function generateStarkPrivateKey(): string {
  const keyPair = legacy.starkEc.genKeyPair();
  return legacy.grindKey(keyPair.getPrivate('hex'));
}

async function getKeyFromPath(
  seed: string,
  path: string,
  ethAddress?: string,
): Promise<string> {
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  // This section is legacy crypto.

  // Same code as legacy.getKeyPairFromPath, required to check if the generated private key
  // goes above the limit when hashed for first time to identify if we need to do backwards
  // compatibility check:
  const privateKeyString = legacy.getPrivateKeyFromPath(seed, path);
  const starkPrivateKey = legacy.grindKey(privateKeyString);

  // The following logic is added in response to bug found in DX-2167 and DX-2184.
  // To provide a backwards compatible way to fetch keys across link/js SDK and Core SDK.

  // The bug only exists if the hashed value of given seed is above the stark curve limit.
  if (!legacy.checkIfHashedKeyIsAboveLimit(privateKeyString)) {
    return starkPrivateKey;
  }

  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  // Check if the generated stark public key matches with the existing account value for that user.
  // We are only validating for Production environment.
  // For Sandbox account/key mismatch, solution is to discard the old account and create a new one.
  const imxResponse = await compatible.getStarkPublicKeyFromImx(ethAddress);
  // If the account is not found or account matches we just return the key pair at the end of this method.
  // Only need to so alternative method if the account is found but the stark public key does not match.

  // If the account is not found it is a new account, just return the Stark Private Key that is generated by gringKey function.
  if (imxResponse?.accountNotFound) {
    return starkPrivateKey;
  }

  // If the user account matches with generated stark public key user, just return Stark Private Key.
  if (
    imxResponse?.starkPublicKey ===
    createStarkSigner(starkPrivateKey).getAddress()
  ) {
    return starkPrivateKey;
  }

  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  // This is backwards compatible crypto (core-sdk)
  const privateKeySeed = compatible.getPrivateKeyFromPath(seed, path);

  // If we are here, we found the account but did not match with the recorded user account.
  // Lets try to use grindKey method from backwards compatible logic to generate a key and see if that matches.
  const starkPrivateKeyCompatible = compatible.grindKey(privateKeySeed);
  if (
    imxResponse?.starkPublicKey ===
    createStarkSigner(starkPrivateKeyCompatible).getAddress()
  ) {
    return starkPrivateKeyCompatible;
  }

  // If we are here, we found the account but did not match with the recorded user account.
  // Lets try to use grindKeyV1 method from backwards compatible to generate a key and see if that matches.
  const starkPrivateKeyCompatibleV1 = compatible.grindKeyV1(privateKeySeed);
  if (
    imxResponse?.starkPublicKey ===
    createStarkSigner(starkPrivateKeyCompatibleV1).getAddress()
  ) {
    return starkPrivateKeyCompatibleV1;
  }
  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  // Account is found, but did not match with stark public keys generated by either grindKey or grindKeyV1 method.
  // Will have to contact support for further investigation.
  throw new Error(
    'Can not deterministically generate stark private key - please contact support',
  );
}

/**
 * Generates a deterministic Stark private key from the provided signer.
 * @returns the private key as a hex string
 */
export async function generateLegacyStarkPrivateKey(
  signer: Signer,
): Promise<string> {
  const address = (await signer.getAddress()).toLowerCase();
  const signature = await signer.signMessage(legacy.DEFAULT_SIGNATURE_MESSAGE);
  const seed = splitSignature(signature).s;
  const path = legacy.getAccountPath(
    legacy.DEFAULT_ACCOUNT_LAYER,
    legacy.DEFAULT_ACCOUNT_APPLICATION,
    address,
    legacy.DEFAULT_ACCOUNT_INDEX,
  );
  const key = await getKeyFromPath(seed, path, address);
  return key.padStart(64, '0');
}
