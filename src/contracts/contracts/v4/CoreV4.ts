/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export interface CoreV4Interface extends utils.Interface {
  functions: {
    "DEPOSIT_CANCEL_DELAY()": FunctionFragment;
    "FREEZE_GRACE_PERIOD()": FunctionFragment;
    "MAIN_GOVERNANCE_INFO_TAG()": FunctionFragment;
    "MAX_FORCED_ACTIONS_REQS_PER_BLOCK()": FunctionFragment;
    "MAX_VERIFIER_COUNT()": FunctionFragment;
    "STARKEX_MAX_DEFAULT_VAULT_LOCK()": FunctionFragment;
    "UNFREEZE_DELAY()": FunctionFragment;
    "VERIFIER_REMOVAL_DELAY()": FunctionFragment;
    "VERSION()": FunctionFragment;
    "announceAvailabilityVerifierRemovalIntent(address)": FunctionFragment;
    "announceVerifierRemovalIntent(address)": FunctionFragment;
    "defaultVaultWithdrawalLock()": FunctionFragment;
    "deposit(uint256,uint256,uint256)": FunctionFragment;
    "deposit(uint256,uint256,uint256,uint256)": FunctionFragment;
    "depositCancel(uint256,uint256,uint256)": FunctionFragment;
    "depositERC20(uint256,uint256,uint256,uint256)": FunctionFragment;
    "depositERC20ToVault(uint256,uint256,uint256)": FunctionFragment;
    "depositEth(uint256,uint256,uint256)": FunctionFragment;
    "depositEthToVault(uint256,uint256)": FunctionFragment;
    "depositNft(uint256,uint256,uint256,uint256)": FunctionFragment;
    "depositNftReclaim(uint256,uint256,uint256,uint256)": FunctionFragment;
    "depositReclaim(uint256,uint256,uint256)": FunctionFragment;
    "escape(uint256,uint256,uint256,uint256)": FunctionFragment;
    "freezeRequest(uint256,uint256)": FunctionFragment;
    "fullWithdrawalRequest(uint256,uint256)": FunctionFragment;
    "getActionCount()": FunctionFragment;
    "getActionHashByIndex(uint256)": FunctionFragment;
    "getAssetInfo(uint256)": FunctionFragment;
    "getCancellationRequest(uint256,uint256,uint256)": FunctionFragment;
    "getDepositBalance(uint256,uint256,uint256)": FunctionFragment;
    "getEthKey(uint256)": FunctionFragment;
    "getFullWithdrawalRequest(uint256,uint256)": FunctionFragment;
    "getLastBatchId()": FunctionFragment;
    "getOrderRoot()": FunctionFragment;
    "getOrderTreeHeight()": FunctionFragment;
    "getQuantizedDepositBalance(uint256,uint256,uint256)": FunctionFragment;
    "getQuantizedVaultBalance(address,uint256,uint256)": FunctionFragment;
    "getQuantum(uint256)": FunctionFragment;
    "getRegisteredAvailabilityVerifiers()": FunctionFragment;
    "getRegisteredVerifiers()": FunctionFragment;
    "getSequenceNumber()": FunctionFragment;
    "getVaultBalance(address,uint256,uint256)": FunctionFragment;
    "getVaultRoot()": FunctionFragment;
    "getVaultTreeHeight()": FunctionFragment;
    "getVaultWithdrawalLock(address,uint256,uint256)": FunctionFragment;
    "getWithdrawalBalance(uint256,uint256)": FunctionFragment;
    "initialize(bytes)": FunctionFragment;
    "isAssetRegistered(uint256)": FunctionFragment;
    "isAvailabilityVerifier(address)": FunctionFragment;
    "isFrozen()": FunctionFragment;
    "isOperator(address)": FunctionFragment;
    "isStrictVaultBalancePolicy()": FunctionFragment;
    "isTokenAdmin(address)": FunctionFragment;
    "isVaultLocked(address,uint256,uint256)": FunctionFragment;
    "isVerifier(address)": FunctionFragment;
    "lockVault(uint256,uint256,uint256)": FunctionFragment;
    "mainAcceptGovernance()": FunctionFragment;
    "mainCancelNomination()": FunctionFragment;
    "mainIsGovernor(address)": FunctionFragment;
    "mainNominateNewGovernor(address)": FunctionFragment;
    "mainRemoveGovernor(address)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "orderRegistryAddress()": FunctionFragment;
    "registerAndDepositERC20(address,uint256,bytes,uint256,uint256,uint256)": FunctionFragment;
    "registerAndDepositEth(address,uint256,bytes,uint256,uint256)": FunctionFragment;
    "registerAvailabilityVerifier(address,string)": FunctionFragment;
    "registerEthAddress(address,uint256,bytes)": FunctionFragment;
    "registerOperator(address)": FunctionFragment;
    "registerSender(uint256,bytes)": FunctionFragment;
    "registerToken(uint256,bytes)": FunctionFragment;
    "registerToken(uint256,bytes,uint256)": FunctionFragment;
    "registerTokenAdmin(address)": FunctionFragment;
    "registerVerifier(address,string)": FunctionFragment;
    "removeAvailabilityVerifier(address)": FunctionFragment;
    "removeVerifier(address)": FunctionFragment;
    "setDefaultVaultWithdrawalLock(uint256)": FunctionFragment;
    "unFreeze()": FunctionFragment;
    "unregisterOperator(address)": FunctionFragment;
    "unregisterTokenAdmin(address)": FunctionFragment;
    "updateImplementationActivationTime(address,bytes,bool)": FunctionFragment;
    "updateState(uint256[],uint256[])": FunctionFragment;
    "withdraw(uint256,uint256)": FunctionFragment;
    "withdrawAndMint(uint256,uint256,bytes)": FunctionFragment;
    "withdrawFromVault(uint256,uint256,uint256)": FunctionFragment;
    "withdrawNft(uint256,uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DEPOSIT_CANCEL_DELAY"
      | "FREEZE_GRACE_PERIOD"
      | "MAIN_GOVERNANCE_INFO_TAG"
      | "MAX_FORCED_ACTIONS_REQS_PER_BLOCK"
      | "MAX_VERIFIER_COUNT"
      | "STARKEX_MAX_DEFAULT_VAULT_LOCK"
      | "UNFREEZE_DELAY"
      | "VERIFIER_REMOVAL_DELAY"
      | "VERSION"
      | "announceAvailabilityVerifierRemovalIntent"
      | "announceVerifierRemovalIntent"
      | "defaultVaultWithdrawalLock"
      | "deposit(uint256,uint256,uint256)"
      | "deposit(uint256,uint256,uint256,uint256)"
      | "depositCancel"
      | "depositERC20"
      | "depositERC20ToVault"
      | "depositEth"
      | "depositEthToVault"
      | "depositNft"
      | "depositNftReclaim"
      | "depositReclaim"
      | "escape"
      | "freezeRequest"
      | "fullWithdrawalRequest"
      | "getActionCount"
      | "getActionHashByIndex"
      | "getAssetInfo"
      | "getCancellationRequest"
      | "getDepositBalance"
      | "getEthKey"
      | "getFullWithdrawalRequest"
      | "getLastBatchId"
      | "getOrderRoot"
      | "getOrderTreeHeight"
      | "getQuantizedDepositBalance"
      | "getQuantizedVaultBalance"
      | "getQuantum"
      | "getRegisteredAvailabilityVerifiers"
      | "getRegisteredVerifiers"
      | "getSequenceNumber"
      | "getVaultBalance"
      | "getVaultRoot"
      | "getVaultTreeHeight"
      | "getVaultWithdrawalLock"
      | "getWithdrawalBalance"
      | "initialize"
      | "isAssetRegistered"
      | "isAvailabilityVerifier"
      | "isFrozen"
      | "isOperator"
      | "isStrictVaultBalancePolicy"
      | "isTokenAdmin"
      | "isVaultLocked"
      | "isVerifier"
      | "lockVault"
      | "mainAcceptGovernance"
      | "mainCancelNomination"
      | "mainIsGovernor"
      | "mainNominateNewGovernor"
      | "mainRemoveGovernor"
      | "onERC721Received"
      | "orderRegistryAddress"
      | "registerAndDepositERC20"
      | "registerAndDepositEth"
      | "registerAvailabilityVerifier"
      | "registerEthAddress"
      | "registerOperator"
      | "registerSender"
      | "registerToken(uint256,bytes)"
      | "registerToken(uint256,bytes,uint256)"
      | "registerTokenAdmin"
      | "registerVerifier"
      | "removeAvailabilityVerifier"
      | "removeVerifier"
      | "setDefaultVaultWithdrawalLock"
      | "unFreeze"
      | "unregisterOperator"
      | "unregisterTokenAdmin"
      | "updateImplementationActivationTime"
      | "updateState"
      | "withdraw"
      | "withdrawAndMint"
      | "withdrawFromVault"
      | "withdrawNft"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DEPOSIT_CANCEL_DELAY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FREEZE_GRACE_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAIN_GOVERNANCE_INFO_TAG",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_FORCED_ACTIONS_REQS_PER_BLOCK",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_VERIFIER_COUNT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "STARKEX_MAX_DEFAULT_VAULT_LOCK",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UNFREEZE_DELAY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VERIFIER_REMOVAL_DELAY",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "VERSION", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "announceAvailabilityVerifierRemovalIntent",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "announceVerifierRemovalIntent",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "defaultVaultWithdrawalLock",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deposit(uint256,uint256,uint256)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit(uint256,uint256,uint256,uint256)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositCancel",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositERC20",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositERC20ToVault",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositEth",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositEthToVault",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositNft",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositNftReclaim",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositReclaim",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "escape",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeRequest",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fullWithdrawalRequest",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActionCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActionHashByIndex",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCancellationRequest",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDepositBalance",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getEthKey",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFullWithdrawalRequest",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLastBatchId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderRoot",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderTreeHeight",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getQuantizedDepositBalance",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getQuantizedVaultBalance",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getQuantum",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRegisteredAvailabilityVerifiers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRegisteredVerifiers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSequenceNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultBalance",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultRoot",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultTreeHeight",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultWithdrawalLock",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getWithdrawalBalance",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAssetRegistered",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAvailabilityVerifier",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "isFrozen", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isOperator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStrictVaultBalancePolicy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isTokenAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isVaultLocked",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isVerifier",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "lockVault",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mainAcceptGovernance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mainCancelNomination",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mainIsGovernor",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "mainNominateNewGovernor",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "mainRemoveGovernor",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "orderRegistryAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "registerAndDepositERC20",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAndDepositEth",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAvailabilityVerifier",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerEthAddress",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "registerOperator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerSender",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerToken(uint256,bytes)",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerToken(uint256,bytes,uint256)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "registerTokenAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerVerifier",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAvailabilityVerifier",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeVerifier",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDefaultVaultWithdrawalLock",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "unFreeze", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "unregisterOperator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unregisterTokenAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateImplementationActivationTime",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateState",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawAndMint",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawFromVault",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawNft",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "DEPOSIT_CANCEL_DELAY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FREEZE_GRACE_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAIN_GOVERNANCE_INFO_TAG",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_FORCED_ACTIONS_REQS_PER_BLOCK",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_VERIFIER_COUNT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "STARKEX_MAX_DEFAULT_VAULT_LOCK",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "UNFREEZE_DELAY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VERIFIER_REMOVAL_DELAY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "VERSION", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "announceAvailabilityVerifierRemovalIntent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "announceVerifierRemovalIntent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "defaultVaultWithdrawalLock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deposit(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deposit(uint256,uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositCancel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20ToVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositEth", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositEthToVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositNft", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositNftReclaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositReclaim",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "escape", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "freezeRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fullWithdrawalRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActionCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActionHashByIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCancellationRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDepositBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getEthKey", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getFullWithdrawalRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastBatchId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOrderRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOrderTreeHeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getQuantizedDepositBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getQuantizedVaultBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getQuantum", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRegisteredAvailabilityVerifiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRegisteredVerifiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSequenceNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultTreeHeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultWithdrawalLock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWithdrawalBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isAssetRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAvailabilityVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isFrozen", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isOperator", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isStrictVaultBalancePolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTokenAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isVaultLocked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isVerifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lockVault", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mainAcceptGovernance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mainCancelNomination",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mainIsGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mainNominateNewGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mainRemoveGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "orderRegistryAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAndDepositERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAndDepositEth",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAvailabilityVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerEthAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerSender",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerToken(uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerToken(uint256,bytes,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerTokenAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAvailabilityVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDefaultVaultWithdrawalLock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unFreeze", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unregisterOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unregisterTokenAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateImplementationActivationTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawAndMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawFromVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawNft",
    data: BytesLike
  ): Result;

  events: {
    "ImplementationActivationRescheduled(address,uint256)": EventFragment;
    "LogDefaultVaultWithdrawalLockSet(uint256)": EventFragment;
    "LogDeposit(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "LogDepositCancel(uint256,uint256,uint256)": EventFragment;
    "LogDepositCancelReclaimed(uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "LogDepositNftCancelReclaimed(uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "LogDepositToVault(address,uint256,uint256,uint256,uint256)": EventFragment;
    "LogFrozen()": EventFragment;
    "LogFullWithdrawalRequest(uint256,uint256)": EventFragment;
    "LogMintWithdrawalPerformed(uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "LogMintableWithdrawalAllowed(uint256,uint256,uint256)": EventFragment;
    "LogNewGovernorAccepted(address)": EventFragment;
    "LogNftDeposit(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "LogNftWithdrawalAllowed(uint256,uint256)": EventFragment;
    "LogNftWithdrawalPerformed(uint256,uint256,uint256,uint256,address)": EventFragment;
    "LogNominatedGovernor(address)": EventFragment;
    "LogNominationCancelled()": EventFragment;
    "LogOperatorAdded(address)": EventFragment;
    "LogOperatorRemoved(address)": EventFragment;
    "LogRegistered(address,string)": EventFragment;
    "LogRemovalIntent(address,string)": EventFragment;
    "LogRemoved(address,string)": EventFragment;
    "LogRemovedGovernor(address)": EventFragment;
    "LogRootUpdate(uint256,uint256,uint256,uint256)": EventFragment;
    "LogStateTransitionFact(bytes32)": EventFragment;
    "LogTokenAdminAdded(address)": EventFragment;
    "LogTokenAdminRemoved(address)": EventFragment;
    "LogTokenRegistered(uint256,bytes,uint256)": EventFragment;
    "LogUnFrozen()": EventFragment;
    "LogUserRegistered(address,uint256,address)": EventFragment;
    "LogVaultBalanceChangeApplied(address,uint256,uint256,int256)": EventFragment;
    "LogVaultWithdrawalLockSet(address,uint256,uint256,uint256)": EventFragment;
    "LogWithdrawalAllowed(uint256,uint256,uint256,uint256)": EventFragment;
    "LogWithdrawalFromVault(address,uint256,uint256,uint256,uint256)": EventFragment;
    "LogWithdrawalPerformed(uint256,uint256,uint256,uint256,address)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "ImplementationActivationRescheduled"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogDefaultVaultWithdrawalLockSet"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogDepositCancel"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogDepositCancelReclaimed"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogDepositNftCancelReclaimed"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogDepositToVault"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogFrozen"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogFullWithdrawalRequest"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogMintWithdrawalPerformed"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogMintableWithdrawalAllowed"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNewGovernorAccepted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNftDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNftWithdrawalAllowed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNftWithdrawalPerformed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNominatedGovernor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNominationCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogOperatorAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogOperatorRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRemovalIntent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRemovedGovernor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRootUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStateTransitionFact"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogTokenAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogTokenAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogTokenRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogUnFrozen"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogUserRegistered"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogVaultBalanceChangeApplied"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogVaultWithdrawalLockSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogWithdrawalAllowed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogWithdrawalFromVault"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogWithdrawalPerformed"): EventFragment;
}

export interface ImplementationActivationRescheduledEventObject {
  implementation: string;
  updatedActivationTime: BigNumber;
}
export type ImplementationActivationRescheduledEvent = TypedEvent<
  [string, BigNumber],
  ImplementationActivationRescheduledEventObject
>;

export type ImplementationActivationRescheduledEventFilter =
  TypedEventFilter<ImplementationActivationRescheduledEvent>;

export interface LogDefaultVaultWithdrawalLockSetEventObject {
  newDefaultLockTime: BigNumber;
}
export type LogDefaultVaultWithdrawalLockSetEvent = TypedEvent<
  [BigNumber],
  LogDefaultVaultWithdrawalLockSetEventObject
>;

export type LogDefaultVaultWithdrawalLockSetEventFilter =
  TypedEventFilter<LogDefaultVaultWithdrawalLockSetEvent>;

export interface LogDepositEventObject {
  depositorEthKey: string;
  starkKey: BigNumber;
  vaultId: BigNumber;
  assetType: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
}
export type LogDepositEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  LogDepositEventObject
>;

export type LogDepositEventFilter = TypedEventFilter<LogDepositEvent>;

export interface LogDepositCancelEventObject {
  starkKey: BigNumber;
  vaultId: BigNumber;
  assetId: BigNumber;
}
export type LogDepositCancelEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  LogDepositCancelEventObject
>;

export type LogDepositCancelEventFilter =
  TypedEventFilter<LogDepositCancelEvent>;

export interface LogDepositCancelReclaimedEventObject {
  starkKey: BigNumber;
  vaultId: BigNumber;
  assetType: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
}
export type LogDepositCancelReclaimedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  LogDepositCancelReclaimedEventObject
>;

export type LogDepositCancelReclaimedEventFilter =
  TypedEventFilter<LogDepositCancelReclaimedEvent>;

export interface LogDepositNftCancelReclaimedEventObject {
  starkKey: BigNumber;
  vaultId: BigNumber;
  assetType: BigNumber;
  tokenId: BigNumber;
  assetId: BigNumber;
}
export type LogDepositNftCancelReclaimedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  LogDepositNftCancelReclaimedEventObject
>;

export type LogDepositNftCancelReclaimedEventFilter =
  TypedEventFilter<LogDepositNftCancelReclaimedEvent>;

export interface LogDepositToVaultEventObject {
  ethKey: string;
  assetId: BigNumber;
  vaultId: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
}
export type LogDepositToVaultEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber],
  LogDepositToVaultEventObject
>;

export type LogDepositToVaultEventFilter =
  TypedEventFilter<LogDepositToVaultEvent>;

export interface LogFrozenEventObject {}
export type LogFrozenEvent = TypedEvent<[], LogFrozenEventObject>;

export type LogFrozenEventFilter = TypedEventFilter<LogFrozenEvent>;

export interface LogFullWithdrawalRequestEventObject {
  starkKey: BigNumber;
  vaultId: BigNumber;
}
export type LogFullWithdrawalRequestEvent = TypedEvent<
  [BigNumber, BigNumber],
  LogFullWithdrawalRequestEventObject
>;

export type LogFullWithdrawalRequestEventFilter =
  TypedEventFilter<LogFullWithdrawalRequestEvent>;

export interface LogMintWithdrawalPerformedEventObject {
  ownerKey: BigNumber;
  assetType: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
  assetId: BigNumber;
}
export type LogMintWithdrawalPerformedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  LogMintWithdrawalPerformedEventObject
>;

export type LogMintWithdrawalPerformedEventFilter =
  TypedEventFilter<LogMintWithdrawalPerformedEvent>;

export interface LogMintableWithdrawalAllowedEventObject {
  ownerKey: BigNumber;
  assetId: BigNumber;
  quantizedAmount: BigNumber;
}
export type LogMintableWithdrawalAllowedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  LogMintableWithdrawalAllowedEventObject
>;

export type LogMintableWithdrawalAllowedEventFilter =
  TypedEventFilter<LogMintableWithdrawalAllowedEvent>;

export interface LogNewGovernorAcceptedEventObject {
  acceptedGovernor: string;
}
export type LogNewGovernorAcceptedEvent = TypedEvent<
  [string],
  LogNewGovernorAcceptedEventObject
>;

export type LogNewGovernorAcceptedEventFilter =
  TypedEventFilter<LogNewGovernorAcceptedEvent>;

export interface LogNftDepositEventObject {
  depositorEthKey: string;
  starkKey: BigNumber;
  vaultId: BigNumber;
  assetType: BigNumber;
  tokenId: BigNumber;
  assetId: BigNumber;
}
export type LogNftDepositEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  LogNftDepositEventObject
>;

export type LogNftDepositEventFilter = TypedEventFilter<LogNftDepositEvent>;

export interface LogNftWithdrawalAllowedEventObject {
  ownerKey: BigNumber;
  assetId: BigNumber;
}
export type LogNftWithdrawalAllowedEvent = TypedEvent<
  [BigNumber, BigNumber],
  LogNftWithdrawalAllowedEventObject
>;

export type LogNftWithdrawalAllowedEventFilter =
  TypedEventFilter<LogNftWithdrawalAllowedEvent>;

export interface LogNftWithdrawalPerformedEventObject {
  ownerKey: BigNumber;
  assetType: BigNumber;
  tokenId: BigNumber;
  assetId: BigNumber;
  recipient: string;
}
export type LogNftWithdrawalPerformedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, string],
  LogNftWithdrawalPerformedEventObject
>;

export type LogNftWithdrawalPerformedEventFilter =
  TypedEventFilter<LogNftWithdrawalPerformedEvent>;

export interface LogNominatedGovernorEventObject {
  nominatedGovernor: string;
}
export type LogNominatedGovernorEvent = TypedEvent<
  [string],
  LogNominatedGovernorEventObject
>;

export type LogNominatedGovernorEventFilter =
  TypedEventFilter<LogNominatedGovernorEvent>;

export interface LogNominationCancelledEventObject {}
export type LogNominationCancelledEvent = TypedEvent<
  [],
  LogNominationCancelledEventObject
>;

export type LogNominationCancelledEventFilter =
  TypedEventFilter<LogNominationCancelledEvent>;

export interface LogOperatorAddedEventObject {
  operator: string;
}
export type LogOperatorAddedEvent = TypedEvent<
  [string],
  LogOperatorAddedEventObject
>;

export type LogOperatorAddedEventFilter =
  TypedEventFilter<LogOperatorAddedEvent>;

export interface LogOperatorRemovedEventObject {
  operator: string;
}
export type LogOperatorRemovedEvent = TypedEvent<
  [string],
  LogOperatorRemovedEventObject
>;

export type LogOperatorRemovedEventFilter =
  TypedEventFilter<LogOperatorRemovedEvent>;

export interface LogRegisteredEventObject {
  entry: string;
  entryId: string;
}
export type LogRegisteredEvent = TypedEvent<
  [string, string],
  LogRegisteredEventObject
>;

export type LogRegisteredEventFilter = TypedEventFilter<LogRegisteredEvent>;

export interface LogRemovalIntentEventObject {
  entry: string;
  entryId: string;
}
export type LogRemovalIntentEvent = TypedEvent<
  [string, string],
  LogRemovalIntentEventObject
>;

export type LogRemovalIntentEventFilter =
  TypedEventFilter<LogRemovalIntentEvent>;

export interface LogRemovedEventObject {
  entry: string;
  entryId: string;
}
export type LogRemovedEvent = TypedEvent<
  [string, string],
  LogRemovedEventObject
>;

export type LogRemovedEventFilter = TypedEventFilter<LogRemovedEvent>;

export interface LogRemovedGovernorEventObject {
  removedGovernor: string;
}
export type LogRemovedGovernorEvent = TypedEvent<
  [string],
  LogRemovedGovernorEventObject
>;

export type LogRemovedGovernorEventFilter =
  TypedEventFilter<LogRemovedGovernorEvent>;

export interface LogRootUpdateEventObject {
  sequenceNumber: BigNumber;
  batchId: BigNumber;
  vaultRoot: BigNumber;
  orderRoot: BigNumber;
}
export type LogRootUpdateEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber],
  LogRootUpdateEventObject
>;

export type LogRootUpdateEventFilter = TypedEventFilter<LogRootUpdateEvent>;

export interface LogStateTransitionFactEventObject {
  stateTransitionFact: string;
}
export type LogStateTransitionFactEvent = TypedEvent<
  [string],
  LogStateTransitionFactEventObject
>;

export type LogStateTransitionFactEventFilter =
  TypedEventFilter<LogStateTransitionFactEvent>;

export interface LogTokenAdminAddedEventObject {
  tokenAdmin: string;
}
export type LogTokenAdminAddedEvent = TypedEvent<
  [string],
  LogTokenAdminAddedEventObject
>;

export type LogTokenAdminAddedEventFilter =
  TypedEventFilter<LogTokenAdminAddedEvent>;

export interface LogTokenAdminRemovedEventObject {
  tokenAdmin: string;
}
export type LogTokenAdminRemovedEvent = TypedEvent<
  [string],
  LogTokenAdminRemovedEventObject
>;

export type LogTokenAdminRemovedEventFilter =
  TypedEventFilter<LogTokenAdminRemovedEvent>;

export interface LogTokenRegisteredEventObject {
  assetType: BigNumber;
  assetInfo: string;
  quantum: BigNumber;
}
export type LogTokenRegisteredEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  LogTokenRegisteredEventObject
>;

export type LogTokenRegisteredEventFilter =
  TypedEventFilter<LogTokenRegisteredEvent>;

export interface LogUnFrozenEventObject {}
export type LogUnFrozenEvent = TypedEvent<[], LogUnFrozenEventObject>;

export type LogUnFrozenEventFilter = TypedEventFilter<LogUnFrozenEvent>;

export interface LogUserRegisteredEventObject {
  ethKey: string;
  starkKey: BigNumber;
  sender: string;
}
export type LogUserRegisteredEvent = TypedEvent<
  [string, BigNumber, string],
  LogUserRegisteredEventObject
>;

export type LogUserRegisteredEventFilter =
  TypedEventFilter<LogUserRegisteredEvent>;

export interface LogVaultBalanceChangeAppliedEventObject {
  ethKey: string;
  assetId: BigNumber;
  vaultId: BigNumber;
  quantizedAmountChange: BigNumber;
}
export type LogVaultBalanceChangeAppliedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  LogVaultBalanceChangeAppliedEventObject
>;

export type LogVaultBalanceChangeAppliedEventFilter =
  TypedEventFilter<LogVaultBalanceChangeAppliedEvent>;

export interface LogVaultWithdrawalLockSetEventObject {
  ethKey: string;
  assetId: BigNumber;
  vaultId: BigNumber;
  timeRelease: BigNumber;
}
export type LogVaultWithdrawalLockSetEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  LogVaultWithdrawalLockSetEventObject
>;

export type LogVaultWithdrawalLockSetEventFilter =
  TypedEventFilter<LogVaultWithdrawalLockSetEvent>;

export interface LogWithdrawalAllowedEventObject {
  ownerKey: BigNumber;
  assetType: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
}
export type LogWithdrawalAllowedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber],
  LogWithdrawalAllowedEventObject
>;

export type LogWithdrawalAllowedEventFilter =
  TypedEventFilter<LogWithdrawalAllowedEvent>;

export interface LogWithdrawalFromVaultEventObject {
  ethKey: string;
  assetId: BigNumber;
  vaultId: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
}
export type LogWithdrawalFromVaultEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber],
  LogWithdrawalFromVaultEventObject
>;

export type LogWithdrawalFromVaultEventFilter =
  TypedEventFilter<LogWithdrawalFromVaultEvent>;

export interface LogWithdrawalPerformedEventObject {
  ownerKey: BigNumber;
  assetType: BigNumber;
  nonQuantizedAmount: BigNumber;
  quantizedAmount: BigNumber;
  recipient: string;
}
export type LogWithdrawalPerformedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, string],
  LogWithdrawalPerformedEventObject
>;

export type LogWithdrawalPerformedEventFilter =
  TypedEventFilter<LogWithdrawalPerformedEvent>;

export interface CoreV4 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CoreV4Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DEPOSIT_CANCEL_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    FREEZE_GRACE_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAIN_GOVERNANCE_INFO_TAG(overrides?: CallOverrides): Promise<[string]>;

    MAX_FORCED_ACTIONS_REQS_PER_BLOCK(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    MAX_VERIFIER_COUNT(overrides?: CallOverrides): Promise<[BigNumber]>;

    STARKEX_MAX_DEFAULT_VAULT_LOCK(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    UNFREEZE_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    VERIFIER_REMOVAL_DELAY(overrides?: CallOverrides): Promise<[BigNumber]>;

    VERSION(overrides?: CallOverrides): Promise<[string]>;

    announceAvailabilityVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    announceVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    defaultVaultWithdrawalLock(overrides?: CallOverrides): Promise<[BigNumber]>;

    "deposit(uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "deposit(uint256,uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositCancel(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositERC20(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositERC20ToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositEth(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositEthToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositNft(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositNftReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    escape(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    freezeRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getActionCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    getActionHashByIndex(
      actionIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getAssetInfo(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { assetInfo: string }>;

    getCancellationRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { request: BigNumber }>;

    getDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { balance: BigNumber }>;

    getEthKey(
      ownerKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getFullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { res: BigNumber }>;

    getLastBatchId(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { batchId: BigNumber }>;

    getOrderRoot(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { root: BigNumber }>;

    getOrderTreeHeight(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { height: BigNumber }>;

    getQuantizedDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { balance: BigNumber }>;

    getQuantizedVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getQuantum(
      presumedAssetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { quantum: BigNumber }>;

    getRegisteredAvailabilityVerifiers(
      overrides?: CallOverrides
    ): Promise<[string[]] & { _verifers: string[] }>;

    getRegisteredVerifiers(
      overrides?: CallOverrides
    ): Promise<[string[]] & { _verifers: string[] }>;

    getSequenceNumber(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { seq: BigNumber }>;

    getVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getVaultRoot(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { root: BigNumber }>;

    getVaultTreeHeight(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { height: BigNumber }>;

    getVaultWithdrawalLock(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getWithdrawalBalance(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { balance: BigNumber }>;

    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isAssetRegistered(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isAvailabilityVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isFrozen(overrides?: CallOverrides): Promise<[boolean]>;

    isOperator(
      testedOperator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isStrictVaultBalancePolicy(overrides?: CallOverrides): Promise<[boolean]>;

    isTokenAdmin(
      testedAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isVaultLocked(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    lockVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      lockTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mainAcceptGovernance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mainCancelNomination(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mainIsGovernor(
      testGovernor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    mainNominateNewGovernor(
      newGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mainRemoveGovernor(
      governorForRemoval: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    orderRegistryAddress(overrides?: CallOverrides): Promise<[string]>;

    registerAndDepositERC20(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerAndDepositEth(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerEthAddress(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerOperator(
      newOperator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerSender(
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "registerToken(uint256,bytes)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "registerToken(uint256,bytes,uint256)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      quantum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerTokenAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDefaultVaultWithdrawalLock(
      newDefaultTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unFreeze(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unregisterOperator(
      removedOperator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unregisterTokenAdmin(
      oldAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateImplementationActivationTime(
      implementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      finalize: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateState(
      publicInput: PromiseOrValue<BigNumberish>[],
      applicationData: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawAndMint(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      mintingBlob: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawFromVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawNft(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DEPOSIT_CANCEL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  FREEZE_GRACE_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  MAIN_GOVERNANCE_INFO_TAG(overrides?: CallOverrides): Promise<string>;

  MAX_FORCED_ACTIONS_REQS_PER_BLOCK(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  MAX_VERIFIER_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

  STARKEX_MAX_DEFAULT_VAULT_LOCK(overrides?: CallOverrides): Promise<BigNumber>;

  UNFREEZE_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  VERIFIER_REMOVAL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

  VERSION(overrides?: CallOverrides): Promise<string>;

  announceAvailabilityVerifierRemovalIntent(
    verifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  announceVerifierRemovalIntent(
    verifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  defaultVaultWithdrawalLock(overrides?: CallOverrides): Promise<BigNumber>;

  "deposit(uint256,uint256,uint256)"(
    starkKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "deposit(uint256,uint256,uint256,uint256)"(
    starkKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    quantizedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositCancel(
    starkKey: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositERC20(
    starkKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    quantizedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositERC20ToVault(
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    quantizedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositEth(
    starkKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositEthToVault(
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositNft(
    starkKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositNftReclaim(
    starkKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositReclaim(
    starkKey: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  escape(
    starkKey: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    quantizedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  freezeRequest(
    starkKey: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fullWithdrawalRequest(
    starkKey: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getActionCount(overrides?: CallOverrides): Promise<BigNumber>;

  getActionHashByIndex(
    actionIndex: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getAssetInfo(
    assetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getCancellationRequest(
    starkKey: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getDepositBalance(
    starkKey: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getEthKey(
    ownerKey: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getFullWithdrawalRequest(
    starkKey: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getLastBatchId(overrides?: CallOverrides): Promise<BigNumber>;

  getOrderRoot(overrides?: CallOverrides): Promise<BigNumber>;

  getOrderTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;

  getQuantizedDepositBalance(
    starkKey: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getQuantizedVaultBalance(
    ethKey: PromiseOrValue<string>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getQuantum(
    presumedAssetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getRegisteredAvailabilityVerifiers(
    overrides?: CallOverrides
  ): Promise<string[]>;

  getRegisteredVerifiers(overrides?: CallOverrides): Promise<string[]>;

  getSequenceNumber(overrides?: CallOverrides): Promise<BigNumber>;

  getVaultBalance(
    ethKey: PromiseOrValue<string>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getVaultRoot(overrides?: CallOverrides): Promise<BigNumber>;

  getVaultTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;

  getVaultWithdrawalLock(
    ethKey: PromiseOrValue<string>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getWithdrawalBalance(
    ownerKey: PromiseOrValue<BigNumberish>,
    assetId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isAssetRegistered(
    assetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isAvailabilityVerifier(
    verifierAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isFrozen(overrides?: CallOverrides): Promise<boolean>;

  isOperator(
    testedOperator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStrictVaultBalancePolicy(overrides?: CallOverrides): Promise<boolean>;

  isTokenAdmin(
    testedAdmin: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isVaultLocked(
    ethKey: PromiseOrValue<string>,
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isVerifier(
    verifierAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lockVault(
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    lockTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mainAcceptGovernance(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mainCancelNomination(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mainIsGovernor(
    testGovernor: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  mainNominateNewGovernor(
    newGovernor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mainRemoveGovernor(
    governorForRemoval: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  orderRegistryAddress(overrides?: CallOverrides): Promise<string>;

  registerAndDepositERC20(
    ethKey: PromiseOrValue<string>,
    starkKey: PromiseOrValue<BigNumberish>,
    signature: PromiseOrValue<BytesLike>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    quantizedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerAndDepositEth(
    ethKey: PromiseOrValue<string>,
    starkKey: PromiseOrValue<BigNumberish>,
    signature: PromiseOrValue<BytesLike>,
    assetType: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerAvailabilityVerifier(
    verifier: PromiseOrValue<string>,
    identifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerEthAddress(
    ethKey: PromiseOrValue<string>,
    starkKey: PromiseOrValue<BigNumberish>,
    starkSignature: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerOperator(
    newOperator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerSender(
    starkKey: PromiseOrValue<BigNumberish>,
    starkSignature: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "registerToken(uint256,bytes)"(
    assetType: PromiseOrValue<BigNumberish>,
    assetInfo: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "registerToken(uint256,bytes,uint256)"(
    assetType: PromiseOrValue<BigNumberish>,
    assetInfo: PromiseOrValue<BytesLike>,
    quantum: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerTokenAdmin(
    newAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerVerifier(
    verifier: PromiseOrValue<string>,
    identifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeAvailabilityVerifier(
    verifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeVerifier(
    verifier: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDefaultVaultWithdrawalLock(
    newDefaultTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unFreeze(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unregisterOperator(
    removedOperator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unregisterTokenAdmin(
    oldAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateImplementationActivationTime(
    implementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    finalize: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateState(
    publicInput: PromiseOrValue<BigNumberish>[],
    applicationData: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    ownerKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawAndMint(
    ownerKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    mintingBlob: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawFromVault(
    assetId: PromiseOrValue<BigNumberish>,
    vaultId: PromiseOrValue<BigNumberish>,
    quantizedAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawNft(
    ownerKey: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DEPOSIT_CANCEL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    FREEZE_GRACE_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    MAIN_GOVERNANCE_INFO_TAG(overrides?: CallOverrides): Promise<string>;

    MAX_FORCED_ACTIONS_REQS_PER_BLOCK(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    MAX_VERIFIER_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    STARKEX_MAX_DEFAULT_VAULT_LOCK(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    UNFREEZE_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    VERIFIER_REMOVAL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    VERSION(overrides?: CallOverrides): Promise<string>;

    announceAvailabilityVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    announceVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    defaultVaultWithdrawalLock(overrides?: CallOverrides): Promise<BigNumber>;

    "deposit(uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(uint256,uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositCancel(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositERC20(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositERC20ToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositEth(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositEthToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositNft(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositNftReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    escape(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    freezeRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    fullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getActionCount(overrides?: CallOverrides): Promise<BigNumber>;

    getActionHashByIndex(
      actionIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getAssetInfo(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getCancellationRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEthKey(
      ownerKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getFullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLastBatchId(overrides?: CallOverrides): Promise<BigNumber>;

    getOrderRoot(overrides?: CallOverrides): Promise<BigNumber>;

    getOrderTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getQuantizedDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQuantizedVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQuantum(
      presumedAssetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRegisteredAvailabilityVerifiers(
      overrides?: CallOverrides
    ): Promise<string[]>;

    getRegisteredVerifiers(overrides?: CallOverrides): Promise<string[]>;

    getSequenceNumber(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultRoot(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultWithdrawalLock(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getWithdrawalBalance(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    isAssetRegistered(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isAvailabilityVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isFrozen(overrides?: CallOverrides): Promise<boolean>;

    isOperator(
      testedOperator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStrictVaultBalancePolicy(overrides?: CallOverrides): Promise<boolean>;

    isTokenAdmin(
      testedAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isVaultLocked(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lockVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      lockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    mainAcceptGovernance(overrides?: CallOverrides): Promise<void>;

    mainCancelNomination(overrides?: CallOverrides): Promise<void>;

    mainIsGovernor(
      testGovernor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    mainNominateNewGovernor(
      newGovernor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    mainRemoveGovernor(
      governorForRemoval: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    orderRegistryAddress(overrides?: CallOverrides): Promise<string>;

    registerAndDepositERC20(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerAndDepositEth(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerEthAddress(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerOperator(
      newOperator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerSender(
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    "registerToken(uint256,bytes)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    "registerToken(uint256,bytes,uint256)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      quantum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerTokenAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    registerVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDefaultVaultWithdrawalLock(
      newDefaultTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    unFreeze(overrides?: CallOverrides): Promise<void>;

    unregisterOperator(
      removedOperator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unregisterTokenAdmin(
      oldAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateImplementationActivationTime(
      implementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      finalize: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateState(
      publicInput: PromiseOrValue<BigNumberish>[],
      applicationData: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawAndMint(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      mintingBlob: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawFromVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawNft(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ImplementationActivationRescheduled(address,uint256)"(
      implementation?: PromiseOrValue<string> | null,
      updatedActivationTime?: null
    ): ImplementationActivationRescheduledEventFilter;
    ImplementationActivationRescheduled(
      implementation?: PromiseOrValue<string> | null,
      updatedActivationTime?: null
    ): ImplementationActivationRescheduledEventFilter;

    "LogDefaultVaultWithdrawalLockSet(uint256)"(
      newDefaultLockTime?: null
    ): LogDefaultVaultWithdrawalLockSetEventFilter;
    LogDefaultVaultWithdrawalLockSet(
      newDefaultLockTime?: null
    ): LogDefaultVaultWithdrawalLockSetEventFilter;

    "LogDeposit(address,uint256,uint256,uint256,uint256,uint256)"(
      depositorEthKey?: null,
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogDepositEventFilter;
    LogDeposit(
      depositorEthKey?: null,
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogDepositEventFilter;

    "LogDepositCancel(uint256,uint256,uint256)"(
      starkKey?: null,
      vaultId?: null,
      assetId?: null
    ): LogDepositCancelEventFilter;
    LogDepositCancel(
      starkKey?: null,
      vaultId?: null,
      assetId?: null
    ): LogDepositCancelEventFilter;

    "LogDepositCancelReclaimed(uint256,uint256,uint256,uint256,uint256)"(
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogDepositCancelReclaimedEventFilter;
    LogDepositCancelReclaimed(
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogDepositCancelReclaimedEventFilter;

    "LogDepositNftCancelReclaimed(uint256,uint256,uint256,uint256,uint256)"(
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      tokenId?: null,
      assetId?: null
    ): LogDepositNftCancelReclaimedEventFilter;
    LogDepositNftCancelReclaimed(
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      tokenId?: null,
      assetId?: null
    ): LogDepositNftCancelReclaimedEventFilter;

    "LogDepositToVault(address,uint256,uint256,uint256,uint256)"(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogDepositToVaultEventFilter;
    LogDepositToVault(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogDepositToVaultEventFilter;

    "LogFrozen()"(): LogFrozenEventFilter;
    LogFrozen(): LogFrozenEventFilter;

    "LogFullWithdrawalRequest(uint256,uint256)"(
      starkKey?: null,
      vaultId?: null
    ): LogFullWithdrawalRequestEventFilter;
    LogFullWithdrawalRequest(
      starkKey?: null,
      vaultId?: null
    ): LogFullWithdrawalRequestEventFilter;

    "LogMintWithdrawalPerformed(uint256,uint256,uint256,uint256,uint256)"(
      ownerKey?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null,
      assetId?: null
    ): LogMintWithdrawalPerformedEventFilter;
    LogMintWithdrawalPerformed(
      ownerKey?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null,
      assetId?: null
    ): LogMintWithdrawalPerformedEventFilter;

    "LogMintableWithdrawalAllowed(uint256,uint256,uint256)"(
      ownerKey?: null,
      assetId?: null,
      quantizedAmount?: null
    ): LogMintableWithdrawalAllowedEventFilter;
    LogMintableWithdrawalAllowed(
      ownerKey?: null,
      assetId?: null,
      quantizedAmount?: null
    ): LogMintableWithdrawalAllowedEventFilter;

    "LogNewGovernorAccepted(address)"(
      acceptedGovernor?: null
    ): LogNewGovernorAcceptedEventFilter;
    LogNewGovernorAccepted(
      acceptedGovernor?: null
    ): LogNewGovernorAcceptedEventFilter;

    "LogNftDeposit(address,uint256,uint256,uint256,uint256,uint256)"(
      depositorEthKey?: null,
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      tokenId?: null,
      assetId?: null
    ): LogNftDepositEventFilter;
    LogNftDeposit(
      depositorEthKey?: null,
      starkKey?: null,
      vaultId?: null,
      assetType?: null,
      tokenId?: null,
      assetId?: null
    ): LogNftDepositEventFilter;

    "LogNftWithdrawalAllowed(uint256,uint256)"(
      ownerKey?: null,
      assetId?: null
    ): LogNftWithdrawalAllowedEventFilter;
    LogNftWithdrawalAllowed(
      ownerKey?: null,
      assetId?: null
    ): LogNftWithdrawalAllowedEventFilter;

    "LogNftWithdrawalPerformed(uint256,uint256,uint256,uint256,address)"(
      ownerKey?: null,
      assetType?: null,
      tokenId?: null,
      assetId?: null,
      recipient?: null
    ): LogNftWithdrawalPerformedEventFilter;
    LogNftWithdrawalPerformed(
      ownerKey?: null,
      assetType?: null,
      tokenId?: null,
      assetId?: null,
      recipient?: null
    ): LogNftWithdrawalPerformedEventFilter;

    "LogNominatedGovernor(address)"(
      nominatedGovernor?: null
    ): LogNominatedGovernorEventFilter;
    LogNominatedGovernor(
      nominatedGovernor?: null
    ): LogNominatedGovernorEventFilter;

    "LogNominationCancelled()"(): LogNominationCancelledEventFilter;
    LogNominationCancelled(): LogNominationCancelledEventFilter;

    "LogOperatorAdded(address)"(operator?: null): LogOperatorAddedEventFilter;
    LogOperatorAdded(operator?: null): LogOperatorAddedEventFilter;

    "LogOperatorRemoved(address)"(
      operator?: null
    ): LogOperatorRemovedEventFilter;
    LogOperatorRemoved(operator?: null): LogOperatorRemovedEventFilter;

    "LogRegistered(address,string)"(
      entry?: null,
      entryId?: null
    ): LogRegisteredEventFilter;
    LogRegistered(entry?: null, entryId?: null): LogRegisteredEventFilter;

    "LogRemovalIntent(address,string)"(
      entry?: null,
      entryId?: null
    ): LogRemovalIntentEventFilter;
    LogRemovalIntent(entry?: null, entryId?: null): LogRemovalIntentEventFilter;

    "LogRemoved(address,string)"(
      entry?: null,
      entryId?: null
    ): LogRemovedEventFilter;
    LogRemoved(entry?: null, entryId?: null): LogRemovedEventFilter;

    "LogRemovedGovernor(address)"(
      removedGovernor?: null
    ): LogRemovedGovernorEventFilter;
    LogRemovedGovernor(removedGovernor?: null): LogRemovedGovernorEventFilter;

    "LogRootUpdate(uint256,uint256,uint256,uint256)"(
      sequenceNumber?: null,
      batchId?: null,
      vaultRoot?: null,
      orderRoot?: null
    ): LogRootUpdateEventFilter;
    LogRootUpdate(
      sequenceNumber?: null,
      batchId?: null,
      vaultRoot?: null,
      orderRoot?: null
    ): LogRootUpdateEventFilter;

    "LogStateTransitionFact(bytes32)"(
      stateTransitionFact?: null
    ): LogStateTransitionFactEventFilter;
    LogStateTransitionFact(
      stateTransitionFact?: null
    ): LogStateTransitionFactEventFilter;

    "LogTokenAdminAdded(address)"(
      tokenAdmin?: null
    ): LogTokenAdminAddedEventFilter;
    LogTokenAdminAdded(tokenAdmin?: null): LogTokenAdminAddedEventFilter;

    "LogTokenAdminRemoved(address)"(
      tokenAdmin?: null
    ): LogTokenAdminRemovedEventFilter;
    LogTokenAdminRemoved(tokenAdmin?: null): LogTokenAdminRemovedEventFilter;

    "LogTokenRegistered(uint256,bytes,uint256)"(
      assetType?: null,
      assetInfo?: null,
      quantum?: null
    ): LogTokenRegisteredEventFilter;
    LogTokenRegistered(
      assetType?: null,
      assetInfo?: null,
      quantum?: null
    ): LogTokenRegisteredEventFilter;

    "LogUnFrozen()"(): LogUnFrozenEventFilter;
    LogUnFrozen(): LogUnFrozenEventFilter;

    "LogUserRegistered(address,uint256,address)"(
      ethKey?: null,
      starkKey?: null,
      sender?: null
    ): LogUserRegisteredEventFilter;
    LogUserRegistered(
      ethKey?: null,
      starkKey?: null,
      sender?: null
    ): LogUserRegisteredEventFilter;

    "LogVaultBalanceChangeApplied(address,uint256,uint256,int256)"(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      quantizedAmountChange?: null
    ): LogVaultBalanceChangeAppliedEventFilter;
    LogVaultBalanceChangeApplied(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      quantizedAmountChange?: null
    ): LogVaultBalanceChangeAppliedEventFilter;

    "LogVaultWithdrawalLockSet(address,uint256,uint256,uint256)"(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      timeRelease?: null
    ): LogVaultWithdrawalLockSetEventFilter;
    LogVaultWithdrawalLockSet(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      timeRelease?: null
    ): LogVaultWithdrawalLockSetEventFilter;

    "LogWithdrawalAllowed(uint256,uint256,uint256,uint256)"(
      ownerKey?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogWithdrawalAllowedEventFilter;
    LogWithdrawalAllowed(
      ownerKey?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogWithdrawalAllowedEventFilter;

    "LogWithdrawalFromVault(address,uint256,uint256,uint256,uint256)"(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogWithdrawalFromVaultEventFilter;
    LogWithdrawalFromVault(
      ethKey?: null,
      assetId?: null,
      vaultId?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null
    ): LogWithdrawalFromVaultEventFilter;

    "LogWithdrawalPerformed(uint256,uint256,uint256,uint256,address)"(
      ownerKey?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null,
      recipient?: null
    ): LogWithdrawalPerformedEventFilter;
    LogWithdrawalPerformed(
      ownerKey?: null,
      assetType?: null,
      nonQuantizedAmount?: null,
      quantizedAmount?: null,
      recipient?: null
    ): LogWithdrawalPerformedEventFilter;
  };

  estimateGas: {
    DEPOSIT_CANCEL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    FREEZE_GRACE_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    MAIN_GOVERNANCE_INFO_TAG(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_FORCED_ACTIONS_REQS_PER_BLOCK(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    MAX_VERIFIER_COUNT(overrides?: CallOverrides): Promise<BigNumber>;

    STARKEX_MAX_DEFAULT_VAULT_LOCK(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    UNFREEZE_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    VERIFIER_REMOVAL_DELAY(overrides?: CallOverrides): Promise<BigNumber>;

    VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    announceAvailabilityVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    announceVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    defaultVaultWithdrawalLock(overrides?: CallOverrides): Promise<BigNumber>;

    "deposit(uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "deposit(uint256,uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositCancel(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositERC20(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositERC20ToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositEth(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositEthToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositNft(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositNftReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    escape(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    freezeRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getActionCount(overrides?: CallOverrides): Promise<BigNumber>;

    getActionHashByIndex(
      actionIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAssetInfo(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCancellationRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEthKey(
      ownerKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLastBatchId(overrides?: CallOverrides): Promise<BigNumber>;

    getOrderRoot(overrides?: CallOverrides): Promise<BigNumber>;

    getOrderTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getQuantizedDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQuantizedVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getQuantum(
      presumedAssetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRegisteredAvailabilityVerifiers(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRegisteredVerifiers(overrides?: CallOverrides): Promise<BigNumber>;

    getSequenceNumber(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultRoot(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultTreeHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultWithdrawalLock(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getWithdrawalBalance(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isAssetRegistered(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isAvailabilityVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isFrozen(overrides?: CallOverrides): Promise<BigNumber>;

    isOperator(
      testedOperator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStrictVaultBalancePolicy(overrides?: CallOverrides): Promise<BigNumber>;

    isTokenAdmin(
      testedAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isVaultLocked(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lockVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      lockTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mainAcceptGovernance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mainCancelNomination(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mainIsGovernor(
      testGovernor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mainNominateNewGovernor(
      newGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mainRemoveGovernor(
      governorForRemoval: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    orderRegistryAddress(overrides?: CallOverrides): Promise<BigNumber>;

    registerAndDepositERC20(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerAndDepositEth(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerEthAddress(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerOperator(
      newOperator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerSender(
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "registerToken(uint256,bytes)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "registerToken(uint256,bytes,uint256)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      quantum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerTokenAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDefaultVaultWithdrawalLock(
      newDefaultTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unFreeze(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unregisterOperator(
      removedOperator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unregisterTokenAdmin(
      oldAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateImplementationActivationTime(
      implementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      finalize: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateState(
      publicInput: PromiseOrValue<BigNumberish>[],
      applicationData: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawAndMint(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      mintingBlob: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawFromVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawNft(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DEPOSIT_CANCEL_DELAY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    FREEZE_GRACE_PERIOD(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAIN_GOVERNANCE_INFO_TAG(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_FORCED_ACTIONS_REQS_PER_BLOCK(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_VERIFIER_COUNT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    STARKEX_MAX_DEFAULT_VAULT_LOCK(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    UNFREEZE_DELAY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    VERIFIER_REMOVAL_DELAY(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    announceAvailabilityVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    announceVerifierRemovalIntent(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    defaultVaultWithdrawalLock(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "deposit(uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "deposit(uint256,uint256,uint256,uint256)"(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositCancel(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositERC20(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositERC20ToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositEth(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositEthToVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositNft(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositNftReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositReclaim(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    escape(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    freezeRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getActionCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getActionHashByIndex(
      actionIndex: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAssetInfo(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCancellationRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getEthKey(
      ownerKey: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFullWithdrawalRequest(
      starkKey: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLastBatchId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOrderRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOrderTreeHeight(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQuantizedDepositBalance(
      starkKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQuantizedVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getQuantum(
      presumedAssetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRegisteredAvailabilityVerifiers(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRegisteredVerifiers(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSequenceNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVaultBalance(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVaultTreeHeight(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultWithdrawalLock(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getWithdrawalBalance(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isAssetRegistered(
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isAvailabilityVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isFrozen(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isOperator(
      testedOperator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStrictVaultBalancePolicy(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTokenAdmin(
      testedAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isVaultLocked(
      ethKey: PromiseOrValue<string>,
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isVerifier(
      verifierAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lockVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      lockTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mainAcceptGovernance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mainCancelNomination(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mainIsGovernor(
      testGovernor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mainNominateNewGovernor(
      newGovernor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mainRemoveGovernor(
      governorForRemoval: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    orderRegistryAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    registerAndDepositERC20(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerAndDepositEth(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      assetType: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerEthAddress(
      ethKey: PromiseOrValue<string>,
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerOperator(
      newOperator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerSender(
      starkKey: PromiseOrValue<BigNumberish>,
      starkSignature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "registerToken(uint256,bytes)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "registerToken(uint256,bytes,uint256)"(
      assetType: PromiseOrValue<BigNumberish>,
      assetInfo: PromiseOrValue<BytesLike>,
      quantum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerTokenAdmin(
      newAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerVerifier(
      verifier: PromiseOrValue<string>,
      identifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeAvailabilityVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeVerifier(
      verifier: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDefaultVaultWithdrawalLock(
      newDefaultTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unFreeze(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unregisterOperator(
      removedOperator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unregisterTokenAdmin(
      oldAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateImplementationActivationTime(
      implementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      finalize: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateState(
      publicInput: PromiseOrValue<BigNumberish>[],
      applicationData: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawAndMint(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      mintingBlob: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawFromVault(
      assetId: PromiseOrValue<BigNumberish>,
      vaultId: PromiseOrValue<BigNumberish>,
      quantizedAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawNft(
      ownerKey: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
