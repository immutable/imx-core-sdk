/* tslint:disable */
/* eslint-disable */
/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddMetadataSchemaToCollectionRequest } from '../models';
// @ts-ignore
import { Asset } from '../models';
// @ts-ignore
import { CancelOrderRequest } from '../models';
// @ts-ignore
import { CancelOrderResponse } from '../models';
// @ts-ignore
import { Collection } from '../models';
// @ts-ignore
import { CollectionFilter } from '../models';
// @ts-ignore
import { CreateCollectionRequest } from '../models';
// @ts-ignore
import { CreateOrderRequest } from '../models';
// @ts-ignore
import { CreateOrderResponse } from '../models';
// @ts-ignore
import { CreateProjectRequest } from '../models';
// @ts-ignore
import { CreateProjectResponse } from '../models';
// @ts-ignore
import { CreateTradeRequestV1 } from '../models';
// @ts-ignore
import { CreateTradeResponse } from '../models';
// @ts-ignore
import { CreateTransferRequest } from '../models';
// @ts-ignore
import { CreateTransferRequestV1 } from '../models';
// @ts-ignore
import { CreateTransferResponse } from '../models';
// @ts-ignore
import { CreateTransferResponseV1 } from '../models';
// @ts-ignore
import { CreateWithdrawalRequest } from '../models';
// @ts-ignore
import { CreateWithdrawalResponse } from '../models';
// @ts-ignore
import { Deposit } from '../models';
// @ts-ignore
import { GetBalanceResponse } from '../models';
// @ts-ignore
import { GetProjectsResponse } from '../models';
// @ts-ignore
import { GetSignableCancelOrderRequest } from '../models';
// @ts-ignore
import { GetSignableCancelOrderResponse } from '../models';
// @ts-ignore
import { GetSignableDepositRequest } from '../models';
// @ts-ignore
import { GetSignableDepositResponse } from '../models';
// @ts-ignore
import { GetSignableOrderRequest } from '../models';
// @ts-ignore
import { GetSignableOrderResponse } from '../models';
// @ts-ignore
import { GetSignableRegistrationRequest } from '../models';
// @ts-ignore
import { GetSignableRegistrationResponse } from '../models';
// @ts-ignore
import { GetSignableTradeRequest } from '../models';
// @ts-ignore
import { GetSignableTradeResponse } from '../models';
// @ts-ignore
import { GetSignableTransferRequest } from '../models';
// @ts-ignore
import { GetSignableTransferRequestV1 } from '../models';
// @ts-ignore
import { GetSignableTransferResponse } from '../models';
// @ts-ignore
import { GetSignableTransferResponseV1 } from '../models';
// @ts-ignore
import { GetSignableWithdrawalRequest } from '../models';
// @ts-ignore
import { GetSignableWithdrawalResponse } from '../models';
// @ts-ignore
import { GetUsersApiResponse } from '../models';
// @ts-ignore
import { ListAssetsResponse } from '../models';
// @ts-ignore
import { ListBalancesResponse } from '../models';
// @ts-ignore
import { ListCollectionsResponse } from '../models';
// @ts-ignore
import { ListDepositsResponse } from '../models';
// @ts-ignore
import { ListMintsResponse } from '../models';
// @ts-ignore
import { ListOrdersResponse } from '../models';
// @ts-ignore
import { ListTokensResponse } from '../models';
// @ts-ignore
import { ListTradesResponse } from '../models';
// @ts-ignore
import { ListTransfersResponse } from '../models';
// @ts-ignore
import { ListWithdrawalsResponse } from '../models';
// @ts-ignore
import { MetadataSchemaProperty } from '../models';
// @ts-ignore
import { MetadataSchemaRequest } from '../models';
// @ts-ignore
import { Mint } from '../models';
// @ts-ignore
import { MintRequest } from '../models';
// @ts-ignore
import { MintTokensResponse } from '../models';
// @ts-ignore
import { MintableTokenDetails } from '../models';
// @ts-ignore
import { Order } from '../models';
// @ts-ignore
import { Project } from '../models';
// @ts-ignore
import { RegisterUserRequestVerifyEth } from '../models';
// @ts-ignore
import { RegisterUserResponse } from '../models';
// @ts-ignore
import { SuccessResponse } from '../models';
// @ts-ignore
import { TokenDetails } from '../models';
// @ts-ignore
import { Trade } from '../models';
// @ts-ignore
import { Transfer } from '../models';
// @ts-ignore
import { UpdateCollectionRequest } from '../models';
// @ts-ignore
import { Withdrawal } from '../models';
/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetadataSchemaToCollection: async (address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'address', address)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'addMetadataSchemaToCollectionRequest' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'addMetadataSchemaToCollectionRequest', addMetadataSchemaToCollectionRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMetadataSchemaToCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {CancelOrderRequest} cancelOrderRequest cancel an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelOrder', 'id', id)
            // verify required parameter 'cancelOrderRequest' is not null or undefined
            assertParamExists('cancelOrder', 'cancelOrderRequest', cancelOrderRequest)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateCollectionRequest} createCollectionRequest create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('createCollection', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('createCollection', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'createCollectionRequest' is not null or undefined
            assertParamExists('createCollection', 'createCollectionRequest', createCollectionRequest)
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {CreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('createOrder', 'createOrderRequest', createOrderRequest)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('createProject', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('createProject', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'createProjectRequest' is not null or undefined
            assertParamExists('createProject', 'createProjectRequest', createProjectRequest)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {CreateTradeRequestV1} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade: async (createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTradeRequest' is not null or undefined
            assertParamExists('createTrade', 'createTradeRequest', createTradeRequest)
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferRequestV2' is not null or undefined
            assertParamExists('createTransfer', 'createTransferRequestV2', createTransferRequestV2)
            const localVarPath = `/v2/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {CreateTransferRequestV1} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferV1: async (createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferRequest' is not null or undefined
            assertParamExists('createTransferV1', 'createTransferRequest', createTransferRequest)
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawal: async (createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWithdrawalRequest' is not null or undefined
            assertParamExists('createWithdrawal', 'createWithdrawalRequest', createWithdrawalRequest)
            const localVarPath = `/v1/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWithdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (tokenAddress: string, tokenId: string, includeFees?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('getAsset', 'tokenAddress', tokenAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getAsset', 'tokenId', tokenId)
            const localVarPath = `/v1/assets/{token_address}/{token_id}`
                .replace(`{${"token_address"}}`, encodeURIComponent(String(tokenAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner Address of the owner/user
         * @param {string} address Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (owner: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getBalance', 'owner', owner)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBalance', 'address', address)
            const localVarPath = `/v2/balances/{owner}/{address}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getCollection', 'address', address)
            const localVarPath = `/v1/collections/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeposit: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeposit', 'id', id)
            const localVarPath = `/v1/deposits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSchema: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getMetadataSchema', 'address', address)
            const localVarPath = `/v1/collections/{address}/metadata-schema`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID. This is the transaction_id returned from listMints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMint: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMint', 'id', id)
            const localVarPath = `/v1/mints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMintableTokenDetailsByClientTokenId: async (tokenAddress: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('getMintableTokenDetailsByClientTokenId', 'tokenAddress', tokenAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getMintableTokenDetailsByClientTokenId', 'tokenId', tokenId)
            const localVarPath = `/v1/mintable-token/{token_address}/{token_id}`
                .replace(`{${"token_address"}}`, encodeURIComponent(String(tokenAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to true to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrder', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (id: string, iMXSignature: string, iMXTimestamp: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('getProject', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('getProject', 'iMXTimestamp', iMXTimestamp)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get projects
         * @summary Get projects
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('getProjects', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('getProjects', 'iMXTimestamp', iMXTimestamp)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableCancelOrder: async (getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableCancelOrderRequest' is not null or undefined
            assertParamExists('getSignableCancelOrder', 'getSignableCancelOrderRequest', getSignableCancelOrderRequest)
            const localVarPath = `/v1/signable-cancel-order-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableCancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableDeposit: async (getSignableDepositRequest: GetSignableDepositRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableDepositRequest' is not null or undefined
            assertParamExists('getSignableDeposit', 'getSignableDepositRequest', getSignableDepositRequest)
            const localVarPath = `/v1/signable-deposit-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable order V3
         * @summary Get details a signable order V3
         * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableOrder: async (getSignableOrderRequestV3: GetSignableOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableOrderRequestV3' is not null or undefined
            assertParamExists('getSignableOrder', 'getSignableOrderRequestV3', getSignableOrderRequestV3)
            const localVarPath = `/v3/signable-order-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableOrderRequestV3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableRegistration: async (getSignableRegistrationRequest: GetSignableRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableRegistrationRequest' is not null or undefined
            assertParamExists('getSignableRegistration', 'getSignableRegistrationRequest', getSignableRegistrationRequest)
            const localVarPath = `/v1/signable-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable trade V3
         * @summary Get details a signable trade V3
         * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTrade: async (getSignableTradeRequest: GetSignableTradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTradeRequest' is not null or undefined
            assertParamExists('getSignableTrade', 'getSignableTradeRequest', getSignableTradeRequest)
            const localVarPath = `/v3/signable-trade-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransfer: async (getSignableTransferRequestV2: GetSignableTransferRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTransferRequestV2' is not null or undefined
            assertParamExists('getSignableTransfer', 'getSignableTransferRequestV2', getSignableTransferRequestV2)
            const localVarPath = `/v2/signable-transfer-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTransferRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransferV1: async (getSignableTransferRequest: GetSignableTransferRequestV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTransferRequest' is not null or undefined
            assertParamExists('getSignableTransferV1', 'getSignableTransferRequest', getSignableTransferRequest)
            const localVarPath = `/v1/signable-transfer-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableWithdrawal: async (getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableWithdrawalRequest' is not null or undefined
            assertParamExists('getSignableWithdrawal', 'getSignableWithdrawalRequest', getSignableWithdrawalRequest)
            const localVarPath = `/v1/signable-withdrawal-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableWithdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a token
         * @summary Get details of a token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getToken', 'address', address)
            const localVarPath = `/v1/tokens/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTrade', 'id', id)
            const localVarPath = `/v1/trades/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransfer', 'id', id)
            const localVarPath = `/v1/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUsers', 'user', user)
            const localVarPath = `/v1/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawal: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWithdrawal', 'id', id)
            const localVarPath = `/v1/withdrawals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssets: async (pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (sellOrders !== undefined) {
                localVarQueryParameter['sell_orders'] = sellOrders;
            }

            if (buyOrders !== undefined) {
                localVarQueryParameter['buy_orders'] = buyOrders;
            }

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }

            if (collection !== undefined) {
                localVarQueryParameter['collection'] = collection;
            }

            if (updatedMinTimestamp !== undefined) {
                localVarQueryParameter['updated_min_timestamp'] = updatedMinTimestamp;
            }

            if (updatedMaxTimestamp !== undefined) {
                localVarQueryParameter['updated_max_timestamp'] = updatedMaxTimestamp;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner Ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances: async (owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listBalances', 'owner', owner)
            const localVarPath = `/v2/balances/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionFilters: async (address: string, pageSize?: number, nextPageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('listCollectionFilters', 'address', address)
            const localVarPath = `/v1/collections/{address}/filters`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nextPageToken !== undefined) {
                localVarQueryParameter['next_page_token'] = nextPageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (blacklist !== undefined) {
                localVarQueryParameter['blacklist'] = blacklist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeposits: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMints: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (updatedMinTimestamp !== undefined) {
                localVarQueryParameter['updated_min_timestamp'] = updatedMinTimestamp;
            }

            if (updatedMaxTimestamp !== undefined) {
                localVarQueryParameter['updated_max_timestamp'] = updatedMaxTimestamp;
            }

            if (buyTokenType !== undefined) {
                localVarQueryParameter['buy_token_type'] = buyTokenType;
            }

            if (buyTokenId !== undefined) {
                localVarQueryParameter['buy_token_id'] = buyTokenId;
            }

            if (buyAssetId !== undefined) {
                localVarQueryParameter['buy_asset_id'] = buyAssetId;
            }

            if (buyTokenAddress !== undefined) {
                localVarQueryParameter['buy_token_address'] = buyTokenAddress;
            }

            if (buyTokenName !== undefined) {
                localVarQueryParameter['buy_token_name'] = buyTokenName;
            }

            if (buyMinQuantity !== undefined) {
                localVarQueryParameter['buy_min_quantity'] = buyMinQuantity;
            }

            if (buyMaxQuantity !== undefined) {
                localVarQueryParameter['buy_max_quantity'] = buyMaxQuantity;
            }

            if (buyMetadata !== undefined) {
                localVarQueryParameter['buy_metadata'] = buyMetadata;
            }

            if (sellTokenType !== undefined) {
                localVarQueryParameter['sell_token_type'] = sellTokenType;
            }

            if (sellTokenId !== undefined) {
                localVarQueryParameter['sell_token_id'] = sellTokenId;
            }

            if (sellAssetId !== undefined) {
                localVarQueryParameter['sell_asset_id'] = sellAssetId;
            }

            if (sellTokenAddress !== undefined) {
                localVarQueryParameter['sell_token_address'] = sellTokenAddress;
            }

            if (sellTokenName !== undefined) {
                localVarQueryParameter['sell_token_name'] = sellTokenName;
            }

            if (sellMinQuantity !== undefined) {
                localVarQueryParameter['sell_min_quantity'] = sellMinQuantity;
            }

            if (sellMaxQuantity !== undefined) {
                localVarQueryParameter['sell_max_quantity'] = sellMaxQuantity;
            }

            if (sellMetadata !== undefined) {
                localVarQueryParameter['sell_metadata'] = sellMetadata;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (address?: string, symbols?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (partyATokenType !== undefined) {
                localVarQueryParameter['party_a_token_type'] = partyATokenType;
            }

            if (partyATokenAddress !== undefined) {
                localVarQueryParameter['party_a_token_address'] = partyATokenAddress;
            }

            if (partyATokenId !== undefined) {
                localVarQueryParameter['party_a_token_id'] = partyATokenId;
            }

            if (partyBTokenType !== undefined) {
                localVarQueryParameter['party_b_token_type'] = partyBTokenType;
            }

            if (partyBTokenAddress !== undefined) {
                localVarQueryParameter['party_b_token_address'] = partyBTokenAddress;
            }

            if (partyBTokenId !== undefined) {
                localVarQueryParameter['party_b_token_id'] = partyBTokenId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWithdrawals: async (withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withdrawnToWallet !== undefined) {
                localVarQueryParameter['withdrawn_to_wallet'] = withdrawnToWallet;
            }

            if (rollupStatus !== undefined) {
                localVarQueryParameter['rollup_status'] = rollupStatus;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintTokens: async (mintTokensRequestV2: Array<MintRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintTokensRequestV2' is not null or undefined
            assertParamExists('mintTokens', 'mintTokensRequestV2', mintTokensRequestV2)
            const localVarPath = `/v2/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mintTokensRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequestVerifyEth' is not null or undefined
            assertParamExists('registerUser', 'registerUserRequestVerifyEth', registerUserRequestVerifyEth)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequestVerifyEth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateCollection', 'address', address)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('updateCollection', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('updateCollection', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'updateCollectionRequest' is not null or undefined
            assertParamExists('updateCollection', 'updateCollectionRequest', updateCollectionRequest)
            const localVarPath = `/v1/collections/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataSchemaByName: async (address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'address', address)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'name', name)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'metadataSchemaRequest' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'metadataSchemaRequest', metadataSchemaRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema/{name}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metadataSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetadataSchemaToCollection(address, iMXSignature, iMXTimestamp, addMetadataSchemaToCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {CancelOrderRequest} cancelOrderRequest cancel an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(id, cancelOrderRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateCollectionRequest} createCollectionRequest create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(iMXSignature, iMXTimestamp, createCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {CreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(createOrderRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(iMXSignature, iMXTimestamp, createProjectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {CreateTradeRequestV1} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTradeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(createTradeRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {CreateTransferRequestV1} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransferV1(createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransferV1(createTransferRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWithdrawalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWithdrawal(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(tokenAddress, tokenId, includeFees, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner Address of the owner/user
         * @param {string} address Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(owner: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(owner, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeposit(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeposit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataSchema(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetadataSchemaProperty>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataSchema(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID. This is the transaction_id returned from listMints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMint(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMint(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintableTokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMintableTokenDetailsByClientTokenId(tokenAddress, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to true to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, iMXSignature, iMXTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get projects
         * @summary Get projects
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(iMXSignature, iMXTimestamp, pageSize, cursor, orderBy, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableCancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableCancelOrder(getSignableCancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableDeposit(getSignableDepositRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable order V3
         * @summary Get details a signable order V3
         * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableOrder(getSignableOrderRequestV3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableRegistration(getSignableRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable trade V3
         * @summary Get details a signable trade V3
         * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTradeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableTrade(getSignableTradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableTransfer(getSignableTransferRequestV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableTransferV1(getSignableTransferRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableWithdrawalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableWithdrawal(getSignableWithdrawalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a token
         * @summary Get details of a token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawal(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Withdrawal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawal(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssets(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner Ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBalances(owner: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBalances(owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionFilters(address, pageSize, nextPageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(pageSize, cursor, orderBy, direction, blacklist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDepositsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeposits(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMints(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMintsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMints(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrders(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(address?: string, symbols?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(address, symbols, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTradesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransfers(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransfersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWithdrawalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWithdrawals(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintTokens(mintTokensRequestV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequestVerifyEth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(address, iMXSignature, iMXTimestamp, updateCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetadataSchemaByName(address, name, iMXSignature, iMXTimestamp, metadataSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.addMetadataSchemaToCollection(address, iMXSignature, iMXTimestamp, addMetadataSchemaToCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {CancelOrderRequest} cancelOrderRequest cancel an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CancelOrderResponse> {
            return localVarFp.cancelOrder(id, cancelOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateCollectionRequest} createCollectionRequest create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: any): AxiosPromise<Collection> {
            return localVarFp.createCollection(iMXSignature, iMXTimestamp, createCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {CreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateOrderResponse> {
            return localVarFp.createOrder(createOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: any): AxiosPromise<CreateProjectResponse> {
            return localVarFp.createProject(iMXSignature, iMXTimestamp, createProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {CreateTradeRequestV1} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateTradeResponse> {
            return localVarFp.createTrade(createTradeRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateTransferResponse> {
            return localVarFp.createTransfer(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {CreateTransferRequestV1} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferV1(createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateTransferResponseV1> {
            return localVarFp.createTransferV1(createTransferRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateWithdrawalResponse> {
            return localVarFp.createWithdrawal(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: any): AxiosPromise<Asset> {
            return localVarFp.getAsset(tokenAddress, tokenId, includeFees, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner Address of the owner/user
         * @param {string} address Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(owner: string, address: string, options?: any): AxiosPromise<GetBalanceResponse> {
            return localVarFp.getBalance(owner, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(address: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.getCollection(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeposit(id: string, options?: any): AxiosPromise<Deposit> {
            return localVarFp.getDeposit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSchema(address: string, options?: any): AxiosPromise<Array<MetadataSchemaProperty>> {
            return localVarFp.getMetadataSchema(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID. This is the transaction_id returned from listMints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMint(id: string, options?: any): AxiosPromise<Mint> {
            return localVarFp.getMint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: any): AxiosPromise<MintableTokenDetails> {
            return localVarFp.getMintableTokenDetailsByClientTokenId(tokenAddress, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to true to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrder(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(id, iMXSignature, iMXTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Get projects
         * @summary Get projects
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: any): AxiosPromise<GetProjectsResponse> {
            return localVarFp.getProjects(iMXSignature, iMXTimestamp, pageSize, cursor, orderBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: any): AxiosPromise<GetSignableCancelOrderResponse> {
            return localVarFp.getSignableCancelOrder(getSignableCancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: any): AxiosPromise<GetSignableDepositResponse> {
            return localVarFp.getSignableDeposit(getSignableDepositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable order V3
         * @summary Get details a signable order V3
         * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: any): AxiosPromise<GetSignableOrderResponse> {
            return localVarFp.getSignableOrder(getSignableOrderRequestV3, options).then((request) => request(axios, basePath));
        },
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: any): AxiosPromise<GetSignableRegistrationResponse> {
            return localVarFp.getSignableRegistration(getSignableRegistrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable trade V3
         * @summary Get details a signable trade V3
         * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: any): AxiosPromise<GetSignableTradeResponse> {
            return localVarFp.getSignableTrade(getSignableTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: any): AxiosPromise<GetSignableTransferResponse> {
            return localVarFp.getSignableTransfer(getSignableTransferRequestV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: any): AxiosPromise<GetSignableTransferResponseV1> {
            return localVarFp.getSignableTransferV1(getSignableTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: any): AxiosPromise<GetSignableWithdrawalResponse> {
            return localVarFp.getSignableWithdrawal(getSignableWithdrawalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a token
         * @summary Get details of a token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(address: string, options?: any): AxiosPromise<TokenDetails> {
            return localVarFp.getToken(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(id: string, options?: any): AxiosPromise<Trade> {
            return localVarFp.getTrade(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(id: string, options?: any): AxiosPromise<Transfer> {
            return localVarFp.getTransfer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(user: string, options?: any): AxiosPromise<GetUsersApiResponse> {
            return localVarFp.getUsers(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawal(id: string, options?: any): AxiosPromise<Withdrawal> {
            return localVarFp.getWithdrawal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ListAssetsResponse> {
            return localVarFp.listAssets(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner Ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances(owner: string, options?: any): AxiosPromise<ListBalancesResponse> {
            return localVarFp.listBalances(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: any): AxiosPromise<CollectionFilter> {
            return localVarFp.listCollectionFilters(address, pageSize, nextPageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: any): AxiosPromise<ListCollectionsResponse> {
            return localVarFp.listCollections(pageSize, cursor, orderBy, direction, blacklist, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListDepositsResponse> {
            return localVarFp.listDeposits(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMints(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListMintsResponse> {
            return localVarFp.listMints(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ListOrdersResponse> {
            return localVarFp.listOrders(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(address?: string, symbols?: string, options?: any): AxiosPromise<ListTokensResponse> {
            return localVarFp.listTokens(address, symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: any): AxiosPromise<ListTradesResponse> {
            return localVarFp.listTrades(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListTransfersResponse> {
            return localVarFp.listTransfers(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListWithdrawalsResponse> {
            return localVarFp.listWithdrawals(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: any): AxiosPromise<MintTokensResponse> {
            return localVarFp.mintTokens(mintTokensRequestV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options?: any): AxiosPromise<RegisterUserResponse> {
            return localVarFp.registerUser(registerUserRequestVerifyEth, options).then((request) => request(axios, basePath));
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: any): AxiosPromise<Collection> {
            return localVarFp.updateCollection(address, iMXSignature, iMXTimestamp, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateMetadataSchemaByName(address, name, iMXSignature, iMXTimestamp, metadataSchemaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).addMetadataSchemaToCollection(address, iMXSignature, iMXTimestamp, addMetadataSchemaToCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an order
     * @summary cancel an order
     * @param {string} id Order ID to cancel
     * @param {CancelOrderRequest} cancelOrderRequest cancel an order
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public cancelOrder(id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).cancelOrder(id, cancelOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create collection
     * @summary Create collection
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateCollectionRequest} createCollectionRequest create a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createCollection(iMXSignature, iMXTimestamp, createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an order
     * @summary Create an order
     * @param {CreateOrderRequest} createOrderRequest create an order
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createOrder(createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createOrder(createOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a project
     * @summary Create a project
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {CreateProjectRequest} createProjectRequest create a project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createProject(iMXSignature, iMXTimestamp, createProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {CreateTradeRequestV1} createTradeRequest create a trade
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createTrade(createTradeRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createTransfer(createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createTransfer(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {CreateTransferRequestV1} createTransferRequest Create transfer
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createTransferV1(createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createTransferV1(createTransferRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
     * @param {string} [xImxEthAddress] eth address
     * @param {string} [xImxEthSignature] eth signature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createWithdrawal(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId Either ERC721 token ID or internal IMX ID
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getAsset(tokenAddress, tokenId, includeFees, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {string} owner Address of the owner/user
     * @param {string} address Token address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getBalance(owner: string, address: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getBalance(owner, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getCollection(address: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getCollection(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {string} id Deposit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDeposit(id: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDeposit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {string} address Collection contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getMetadataSchema(address: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getMetadataSchema(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {string} id Mint ID. This is the transaction_id returned from listMints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getMint(id: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getMint(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {string} tokenAddress Address of the ERC721 contract
     * @param {string} tokenId ERC721 token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getMintableTokenDetailsByClientTokenId(tokenAddress, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {string} id Order ID
     * @param {boolean} [includeFees] Set flag to true to include fee body for the order
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getOrder(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project
     * @summary Get a project
     * @param {string} id Project ID
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getProject(id, iMXSignature, iMXTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get projects
     * @summary Get projects
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getProjects(iMXSignature, iMXTimestamp, pageSize, cursor, orderBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableCancelOrder(getSignableCancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableDeposit(getSignableDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable order V3
     * @summary Get details a signable order V3
     * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableOrder(getSignableOrderRequestV3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableRegistration(getSignableRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable trade V3
     * @summary Get details a signable trade V3
     * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableTrade(getSignableTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableTransfer(getSignableTransferRequestV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableTransferV1(getSignableTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableWithdrawal(getSignableWithdrawalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {string} address Token Contract Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getToken(address: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getToken(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {string} id Trade ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getTrade(id: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getTrade(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {string} id Transfer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getTransfer(id: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getTransfer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {string} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUsers(user: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUsers(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {string} id Withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getWithdrawal(id: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getWithdrawal(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'updated_at' | 'name'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who owns these assets
     * @param {string} [status] Status of these assets
     * @param {string} [name] Name of the asset to search
     * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
     * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @param {boolean} [includeFees] Set flag to include fees associated with the asset
     * @param {string} [collection] Collection contract address
     * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
     * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listAssets(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {string} owner Ethereum wallet address for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listBalances(owner: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listBalances(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {string} address Collection contract address
     * @param {number} [pageSize] Page size of the result
     * @param {string} [nextPageToken] Next page token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listCollectionFilters(address, pageSize, nextPageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [blacklist] List of collections not to be displayed, separated by commas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listCollections(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listCollections(pageSize, cursor, orderBy, direction, blacklist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this deposit
     * @param {string} [status] Status of this deposit
     * @param {string} [minTimestamp] Minimum timestamp for this deposit
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit
     * @param {string} [tokenType] Token type of the deposited asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the deposited asset
     * @param {string} [tokenName] Token name of the deposited asset
     * @param {string} [minQuantity] Min quantity for the deposited asset
     * @param {string} [maxQuantity] Max quantity for the deposited asset
     * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDeposits(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of mints
     * @summary Get a list of mints
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this mint
     * @param {string} [status] Status of this mint
     * @param {string} [minTimestamp] Minimum timestamp for this mint
     * @param {string} [maxTimestamp] Maximum timestamp for this mint
     * @param {string} [tokenType] Token type of the minted asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenName] Token Name of the minted asset
     * @param {string} [tokenAddress] Token address of the minted asset
     * @param {string} [minQuantity] Min quantity for the minted asset
     * @param {string} [maxQuantity] Max quantity for the minted asset
     * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listMints(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listMints(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this order
     * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
     * @param {string} [minTimestamp] Minimum created at timestamp for this order
     * @param {string} [maxTimestamp] Maximum created at timestamp for this order
     * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
     * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
     * @param {string} [buyTokenType] Token type of the asset this order buys
     * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
     * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
     * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
     * @param {string} [buyTokenName] Token name of the asset this order buys
     * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
     * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
     * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
     * @param {string} [sellTokenType] Token type of the asset this order sells
     * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
     * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
     * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
     * @param {string} [sellTokenName] Token name of the asset this order sells
     * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
     * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
     * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
     * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listOrders(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {string} [address] Contract address of the token
     * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listTokens(address?: string, symbols?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listTokens(address, symbols, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {string} [partyATokenType] Party A\&#39;s sell token type
     * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
     * @param {string} [partyATokenId] Party A\&#39;s sell token id
     * @param {string} [partyBTokenType] Party B\&#39;s sell token type
     * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
     * @param {string} [partyBTokenId] Party B\&#39;s sell token id
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [minTimestamp] Minimum timestamp for this trade
     * @param {string} [maxTimestamp] Maximum timestamp for this trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listTrades(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listTrades(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this transfer
     * @param {'success' | 'failure'} [status] Status of this transfer
     * @param {string} [minTimestamp] Minimum timestamp for this transfer
     * @param {string} [maxTimestamp] Maximum timestamp for this transfer
     * @param {string} [tokenType] Token type of the transferred asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the transferred asset
     * @param {string} [tokenName] Token name of the transferred asset
     * @param {string} [minQuantity] Max quantity for the transferred asset
     * @param {string} [maxQuantity] Max quantity for the transferred asset
     * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listTransfers(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listTransfers(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
     * @param {number} [pageSize] Page size of the result
     * @param {string} [cursor] Cursor
     * @param {string} [orderBy] Property to sort by
     * @param {string} [direction] Direction to sort (asc/desc)
     * @param {string} [user] Ethereum address of the user who submitted this withdrawal
     * @param {string} [status] Status of this withdrawal
     * @param {string} [minTimestamp] Minimum timestamp for this deposit
     * @param {string} [maxTimestamp] Maximum timestamp for this deposit
     * @param {string} [tokenType] Token type of the withdrawn asset
     * @param {string} [tokenId] ERC721 Token ID of the minted asset
     * @param {string} [assetId] Internal IMX ID of the minted asset
     * @param {string} [tokenAddress] Token address of the withdrawn asset
     * @param {string} [tokenName] Token name of the withdrawn asset
     * @param {string} [minQuantity] Min quantity for the withdrawn asset
     * @param {string} [maxQuantity] Max quantity for the withdrawn asset
     * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWithdrawals(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).mintTokens(mintTokensRequestV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a user
     * @summary Registers a user
     * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public registerUser(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).registerUser(registerUserRequestVerifyEth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update collection
     * @summary Update collection
     * @param {string} address Collection contract address
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateCollection(address, iMXSignature, iMXTimestamp, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {string} address Collection contract address
     * @param {string} name Metadata schema name
     * @param {string} iMXSignature String created by signing wallet address and timestamp
     * @param {string} iMXTimestamp Unix Epoc timestamp
     * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateMetadataSchemaByName(address, name, iMXSignature, iMXTimestamp, metadataSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
