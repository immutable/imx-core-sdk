/* tslint:disable */
/* eslint-disable */
/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddMetadataSchemaToCollectionRequest } from '../models';
// @ts-ignore
import { Asset } from '../models';
// @ts-ignore
import { CancelOrderRequest } from '../models';
// @ts-ignore
import { CancelOrderResponse } from '../models';
// @ts-ignore
import { Collection } from '../models';
// @ts-ignore
import { CollectionFilter } from '../models';
// @ts-ignore
import { CreateCollectionRequest } from '../models';
// @ts-ignore
import { CreateOrderRequest } from '../models';
// @ts-ignore
import { CreateOrderResponse } from '../models';
// @ts-ignore
import { CreateProjectRequest } from '../models';
// @ts-ignore
import { CreateProjectResponse } from '../models';
// @ts-ignore
import { CreateTradeRequestV1 } from '../models';
// @ts-ignore
import { CreateTradeResponse } from '../models';
// @ts-ignore
import { CreateTransferRequest } from '../models';
// @ts-ignore
import { CreateTransferRequestV1 } from '../models';
// @ts-ignore
import { CreateTransferResponse } from '../models';
// @ts-ignore
import { CreateTransferResponseV1 } from '../models';
// @ts-ignore
import { CreateWithdrawalRequest } from '../models';
// @ts-ignore
import { CreateWithdrawalResponse } from '../models';
// @ts-ignore
import { Deposit } from '../models';
// @ts-ignore
import { GetBalanceResponse } from '../models';
// @ts-ignore
import { GetProjectsResponse } from '../models';
// @ts-ignore
import { GetSignableCancelOrderRequest } from '../models';
// @ts-ignore
import { GetSignableCancelOrderResponse } from '../models';
// @ts-ignore
import { GetSignableDepositRequest } from '../models';
// @ts-ignore
import { GetSignableDepositResponse } from '../models';
// @ts-ignore
import { GetSignableOrderRequest } from '../models';
// @ts-ignore
import { GetSignableOrderResponse } from '../models';
// @ts-ignore
import { GetSignableRegistrationRequest } from '../models';
// @ts-ignore
import { GetSignableRegistrationResponse } from '../models';
// @ts-ignore
import { GetSignableTradeRequest } from '../models';
// @ts-ignore
import { GetSignableTradeResponse } from '../models';
// @ts-ignore
import { GetSignableTransferRequest } from '../models';
// @ts-ignore
import { GetSignableTransferRequestV1 } from '../models';
// @ts-ignore
import { GetSignableTransferResponse } from '../models';
// @ts-ignore
import { GetSignableTransferResponseV1 } from '../models';
// @ts-ignore
import { GetSignableWithdrawalRequest } from '../models';
// @ts-ignore
import { GetSignableWithdrawalResponse } from '../models';
// @ts-ignore
import { GetUsersApiResponse } from '../models';
// @ts-ignore
import { ListAssetsResponse } from '../models';
// @ts-ignore
import { ListBalancesResponse } from '../models';
// @ts-ignore
import { ListCollectionsResponse } from '../models';
// @ts-ignore
import { ListDepositsResponse } from '../models';
// @ts-ignore
import { ListMintsResponse } from '../models';
// @ts-ignore
import { ListOrdersResponse } from '../models';
// @ts-ignore
import { ListTokensResponse } from '../models';
// @ts-ignore
import { ListTradesResponse } from '../models';
// @ts-ignore
import { ListTransfersResponse } from '../models';
// @ts-ignore
import { ListWithdrawalsResponse } from '../models';
// @ts-ignore
import { MetadataSchemaProperty } from '../models';
// @ts-ignore
import { MetadataSchemaRequest } from '../models';
// @ts-ignore
import { Mint } from '../models';
// @ts-ignore
import { MintRequest } from '../models';
// @ts-ignore
import { MintTokensResponse } from '../models';
// @ts-ignore
import { MintableTokenDetails } from '../models';
// @ts-ignore
import { Order } from '../models';
// @ts-ignore
import { Project } from '../models';
// @ts-ignore
import { RegisterUserRequestVerifyEth } from '../models';
// @ts-ignore
import { RegisterUserResponse } from '../models';
// @ts-ignore
import { SuccessResponse } from '../models';
// @ts-ignore
import { TokenDetails } from '../models';
// @ts-ignore
import { Trade } from '../models';
// @ts-ignore
import { Transfer } from '../models';
// @ts-ignore
import { UpdateCollectionRequest } from '../models';
// @ts-ignore
import { Withdrawal } from '../models';
/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetadataSchemaToCollection: async (address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'address', address)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'addMetadataSchemaToCollectionRequest' is not null or undefined
            assertParamExists('addMetadataSchemaToCollection', 'addMetadataSchemaToCollectionRequest', addMetadataSchemaToCollectionRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMetadataSchemaToCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {CancelOrderRequest} cancelOrderRequest cancel an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelOrder', 'id', id)
            // verify required parameter 'cancelOrderRequest' is not null or undefined
            assertParamExists('cancelOrder', 'cancelOrderRequest', cancelOrderRequest)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateCollectionRequest} createCollectionRequest create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('createCollection', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('createCollection', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'createCollectionRequest' is not null or undefined
            assertParamExists('createCollection', 'createCollectionRequest', createCollectionRequest)
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {CreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('createOrder', 'createOrderRequest', createOrderRequest)
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('createProject', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('createProject', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'createProjectRequest' is not null or undefined
            assertParamExists('createProject', 'createProjectRequest', createProjectRequest)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {CreateTradeRequestV1} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade: async (createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTradeRequest' is not null or undefined
            assertParamExists('createTrade', 'createTradeRequest', createTradeRequest)
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferRequestV2' is not null or undefined
            assertParamExists('createTransfer', 'createTransferRequestV2', createTransferRequestV2)
            const localVarPath = `/v2/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {CreateTransferRequestV1} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferV1: async (createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransferRequest' is not null or undefined
            assertParamExists('createTransferV1', 'createTransferRequest', createTransferRequest)
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawal: async (createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWithdrawalRequest' is not null or undefined
            assertParamExists('createWithdrawal', 'createWithdrawalRequest', createWithdrawalRequest)
            const localVarPath = `/v1/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xImxEthAddress !== undefined && xImxEthAddress !== null) {
                localVarHeaderParameter['x-imx-eth-address'] = String(xImxEthAddress);
            }

            if (xImxEthSignature !== undefined && xImxEthSignature !== null) {
                localVarHeaderParameter['x-imx-eth-signature'] = String(xImxEthSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWithdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (tokenAddress: string, tokenId: string, includeFees?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('getAsset', 'tokenAddress', tokenAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getAsset', 'tokenId', tokenId)
            const localVarPath = `/v1/assets/{token_address}/{token_id}`
                .replace(`{${"token_address"}}`, encodeURIComponent(String(tokenAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner Address of the owner/user
         * @param {string} address Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (owner: string, address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getBalance', 'owner', owner)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBalance', 'address', address)
            const localVarPath = `/v2/balances/{owner}/{address}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getCollection', 'address', address)
            const localVarPath = `/v1/collections/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeposit: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeposit', 'id', id)
            const localVarPath = `/v1/deposits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSchema: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getMetadataSchema', 'address', address)
            const localVarPath = `/v1/collections/{address}/metadata-schema`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID. This is the transaction_id returned from listMints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMint: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMint', 'id', id)
            const localVarPath = `/v1/mints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMintableTokenDetailsByClientTokenId: async (tokenAddress: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('getMintableTokenDetailsByClientTokenId', 'tokenAddress', tokenAddress)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getMintableTokenDetailsByClientTokenId', 'tokenId', tokenId)
            const localVarPath = `/v1/mintable-token/{token_address}/{token_id}`
                .replace(`{${"token_address"}}`, encodeURIComponent(String(tokenAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to true to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrder', 'id', id)
            const localVarPath = `/v1/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (id: string, iMXSignature: string, iMXTimestamp: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('getProject', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('getProject', 'iMXTimestamp', iMXTimestamp)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get projects
         * @summary Get projects
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('getProjects', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('getProjects', 'iMXTimestamp', iMXTimestamp)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableCancelOrder: async (getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableCancelOrderRequest' is not null or undefined
            assertParamExists('getSignableCancelOrder', 'getSignableCancelOrderRequest', getSignableCancelOrderRequest)
            const localVarPath = `/v1/signable-cancel-order-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableCancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableDeposit: async (getSignableDepositRequest: GetSignableDepositRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableDepositRequest' is not null or undefined
            assertParamExists('getSignableDeposit', 'getSignableDepositRequest', getSignableDepositRequest)
            const localVarPath = `/v1/signable-deposit-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable order V3
         * @summary Get details a signable order V3
         * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableOrder: async (getSignableOrderRequestV3: GetSignableOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableOrderRequestV3' is not null or undefined
            assertParamExists('getSignableOrder', 'getSignableOrderRequestV3', getSignableOrderRequestV3)
            const localVarPath = `/v3/signable-order-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableOrderRequestV3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableRegistration: async (getSignableRegistrationRequest: GetSignableRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableRegistrationRequest' is not null or undefined
            assertParamExists('getSignableRegistration', 'getSignableRegistrationRequest', getSignableRegistrationRequest)
            const localVarPath = `/v1/signable-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details a signable trade V3
         * @summary Get details a signable trade V3
         * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTrade: async (getSignableTradeRequest: GetSignableTradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTradeRequest' is not null or undefined
            assertParamExists('getSignableTrade', 'getSignableTradeRequest', getSignableTradeRequest)
            const localVarPath = `/v3/signable-trade-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransfer: async (getSignableTransferRequestV2: GetSignableTransferRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTransferRequestV2' is not null or undefined
            assertParamExists('getSignableTransfer', 'getSignableTransferRequestV2', getSignableTransferRequestV2)
            const localVarPath = `/v2/signable-transfer-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTransferRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransferV1: async (getSignableTransferRequest: GetSignableTransferRequestV1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableTransferRequest' is not null or undefined
            assertParamExists('getSignableTransferV1', 'getSignableTransferRequest', getSignableTransferRequest)
            const localVarPath = `/v1/signable-transfer-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableWithdrawal: async (getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getSignableWithdrawalRequest' is not null or undefined
            assertParamExists('getSignableWithdrawal', 'getSignableWithdrawalRequest', getSignableWithdrawalRequest)
            const localVarPath = `/v1/signable-withdrawal-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSignableWithdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a token
         * @summary Get details of a token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getToken', 'address', address)
            const localVarPath = `/v1/tokens/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTrade', 'id', id)
            const localVarPath = `/v1/trades/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransfer', 'id', id)
            const localVarPath = `/v1/transfers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUsers', 'user', user)
            const localVarPath = `/v1/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawal: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWithdrawal', 'id', id)
            const localVarPath = `/v1/withdrawals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssets: async (pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (sellOrders !== undefined) {
                localVarQueryParameter['sell_orders'] = sellOrders;
            }

            if (buyOrders !== undefined) {
                localVarQueryParameter['buy_orders'] = buyOrders;
            }

            if (includeFees !== undefined) {
                localVarQueryParameter['include_fees'] = includeFees;
            }

            if (collection !== undefined) {
                localVarQueryParameter['collection'] = collection;
            }

            if (updatedMinTimestamp !== undefined) {
                localVarQueryParameter['updated_min_timestamp'] = updatedMinTimestamp;
            }

            if (updatedMaxTimestamp !== undefined) {
                localVarQueryParameter['updated_max_timestamp'] = updatedMaxTimestamp;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner Ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances: async (owner: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listBalances', 'owner', owner)
            const localVarPath = `/v2/balances/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionFilters: async (address: string, pageSize?: number, nextPageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('listCollectionFilters', 'address', address)
            const localVarPath = `/v1/collections/{address}/filters`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nextPageToken !== undefined) {
                localVarQueryParameter['next_page_token'] = nextPageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (blacklist !== undefined) {
                localVarQueryParameter['blacklist'] = blacklist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeposits: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMints: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (updatedMinTimestamp !== undefined) {
                localVarQueryParameter['updated_min_timestamp'] = updatedMinTimestamp;
            }

            if (updatedMaxTimestamp !== undefined) {
                localVarQueryParameter['updated_max_timestamp'] = updatedMaxTimestamp;
            }

            if (buyTokenType !== undefined) {
                localVarQueryParameter['buy_token_type'] = buyTokenType;
            }

            if (buyTokenId !== undefined) {
                localVarQueryParameter['buy_token_id'] = buyTokenId;
            }

            if (buyAssetId !== undefined) {
                localVarQueryParameter['buy_asset_id'] = buyAssetId;
            }

            if (buyTokenAddress !== undefined) {
                localVarQueryParameter['buy_token_address'] = buyTokenAddress;
            }

            if (buyTokenName !== undefined) {
                localVarQueryParameter['buy_token_name'] = buyTokenName;
            }

            if (buyMinQuantity !== undefined) {
                localVarQueryParameter['buy_min_quantity'] = buyMinQuantity;
            }

            if (buyMaxQuantity !== undefined) {
                localVarQueryParameter['buy_max_quantity'] = buyMaxQuantity;
            }

            if (buyMetadata !== undefined) {
                localVarQueryParameter['buy_metadata'] = buyMetadata;
            }

            if (sellTokenType !== undefined) {
                localVarQueryParameter['sell_token_type'] = sellTokenType;
            }

            if (sellTokenId !== undefined) {
                localVarQueryParameter['sell_token_id'] = sellTokenId;
            }

            if (sellAssetId !== undefined) {
                localVarQueryParameter['sell_asset_id'] = sellAssetId;
            }

            if (sellTokenAddress !== undefined) {
                localVarQueryParameter['sell_token_address'] = sellTokenAddress;
            }

            if (sellTokenName !== undefined) {
                localVarQueryParameter['sell_token_name'] = sellTokenName;
            }

            if (sellMinQuantity !== undefined) {
                localVarQueryParameter['sell_min_quantity'] = sellMinQuantity;
            }

            if (sellMaxQuantity !== undefined) {
                localVarQueryParameter['sell_max_quantity'] = sellMaxQuantity;
            }

            if (sellMetadata !== undefined) {
                localVarQueryParameter['sell_metadata'] = sellMetadata;
            }

            if (auxiliaryFeePercentages !== undefined) {
                localVarQueryParameter['auxiliary_fee_percentages'] = auxiliaryFeePercentages;
            }

            if (auxiliaryFeeRecipients !== undefined) {
                localVarQueryParameter['auxiliary_fee_recipients'] = auxiliaryFeeRecipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (address?: string, symbols?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (partyATokenType !== undefined) {
                localVarQueryParameter['party_a_token_type'] = partyATokenType;
            }

            if (partyATokenAddress !== undefined) {
                localVarQueryParameter['party_a_token_address'] = partyATokenAddress;
            }

            if (partyATokenId !== undefined) {
                localVarQueryParameter['party_a_token_id'] = partyATokenId;
            }

            if (partyBTokenType !== undefined) {
                localVarQueryParameter['party_b_token_type'] = partyBTokenType;
            }

            if (partyBTokenAddress !== undefined) {
                localVarQueryParameter['party_b_token_address'] = partyBTokenAddress;
            }

            if (partyBTokenId !== undefined) {
                localVarQueryParameter['party_b_token_id'] = partyBTokenId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: async (pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWithdrawals: async (withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withdrawnToWallet !== undefined) {
                localVarQueryParameter['withdrawn_to_wallet'] = withdrawnToWallet;
            }

            if (rollupStatus !== undefined) {
                localVarQueryParameter['rollup_status'] = rollupStatus;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minTimestamp !== undefined) {
                localVarQueryParameter['min_timestamp'] = minTimestamp;
            }

            if (maxTimestamp !== undefined) {
                localVarQueryParameter['max_timestamp'] = maxTimestamp;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['token_name'] = tokenName;
            }

            if (minQuantity !== undefined) {
                localVarQueryParameter['min_quantity'] = minQuantity;
            }

            if (maxQuantity !== undefined) {
                localVarQueryParameter['max_quantity'] = maxQuantity;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintTokens: async (mintTokensRequestV2: Array<MintRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintTokensRequestV2' is not null or undefined
            assertParamExists('mintTokens', 'mintTokensRequestV2', mintTokensRequestV2)
            const localVarPath = `/v2/mints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mintTokensRequestV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequestVerifyEth' is not null or undefined
            assertParamExists('registerUser', 'registerUserRequestVerifyEth', registerUserRequestVerifyEth)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequestVerifyEth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateCollection', 'address', address)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('updateCollection', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('updateCollection', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'updateCollectionRequest' is not null or undefined
            assertParamExists('updateCollection', 'updateCollectionRequest', updateCollectionRequest)
            const localVarPath = `/v1/collections/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataSchemaByName: async (address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'address', address)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'name', name)
            // verify required parameter 'iMXSignature' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'iMXSignature', iMXSignature)
            // verify required parameter 'iMXTimestamp' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'iMXTimestamp', iMXTimestamp)
            // verify required parameter 'metadataSchemaRequest' is not null or undefined
            assertParamExists('updateMetadataSchemaByName', 'metadataSchemaRequest', metadataSchemaRequest)
            const localVarPath = `/v1/collections/{address}/metadata-schema/{name}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (iMXSignature !== undefined && iMXSignature !== null) {
                localVarHeaderParameter['IMX-Signature'] = String(iMXSignature);
            }

            if (iMXTimestamp !== undefined && iMXTimestamp !== null) {
                localVarHeaderParameter['IMX-Timestamp'] = String(iMXTimestamp);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metadataSchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetadataSchemaToCollection(address, iMXSignature, iMXTimestamp, addMetadataSchemaToCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {CancelOrderRequest} cancelOrderRequest cancel an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(id, cancelOrderRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateCollectionRequest} createCollectionRequest create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(iMXSignature, iMXTimestamp, createCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {CreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(createOrderRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(iMXSignature, iMXTimestamp, createProjectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {CreateTradeRequestV1} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTradeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(createTradeRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {CreateTransferRequestV1} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransferV1(createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransferV1(createTransferRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWithdrawalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWithdrawal(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(tokenAddress, tokenId, includeFees, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner Address of the owner/user
         * @param {string} address Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(owner: string, address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(owner, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeposit(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeposit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataSchema(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetadataSchemaProperty>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataSchema(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID. This is the transaction_id returned from listMints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMint(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMint(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintableTokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMintableTokenDetailsByClientTokenId(tokenAddress, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to true to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, iMXSignature, iMXTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get projects
         * @summary Get projects
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(iMXSignature, iMXTimestamp, pageSize, cursor, orderBy, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableCancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableCancelOrder(getSignableCancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableDeposit(getSignableDepositRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable order V3
         * @summary Get details a signable order V3
         * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableOrder(getSignableOrderRequestV3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableRegistration(getSignableRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details a signable trade V3
         * @summary Get details a signable trade V3
         * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTradeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableTrade(getSignableTradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableTransfer(getSignableTransferRequestV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableTransferResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableTransferV1(getSignableTransferRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignableWithdrawalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignableWithdrawal(getSignableWithdrawalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a token
         * @summary Get details of a token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawal(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Withdrawal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawal(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssets(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner Ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBalances(owner: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBalances(owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionFilters(address, pageSize, nextPageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(pageSize, cursor, orderBy, direction, blacklist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDepositsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeposits(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMints(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMintsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMints(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrders(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(address?: string, symbols?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(address, symbols, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTradesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransfers(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransfersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWithdrawalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWithdrawals(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintTokens(mintTokensRequestV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequestVerifyEth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(address, iMXSignature, iMXTimestamp, updateCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetadataSchemaByName(address, name, iMXSignature, iMXTimestamp, metadataSchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * Add metadata schema to collection
         * @summary Add metadata schema to collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {AddMetadataSchemaToCollectionRequest} addMetadataSchemaToCollectionRequest add metadata schema to a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetadataSchemaToCollection(address: string, iMXSignature: string, iMXTimestamp: string, addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.addMetadataSchemaToCollection(address, iMXSignature, iMXTimestamp, addMetadataSchemaToCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an order
         * @summary cancel an order
         * @param {string} id Order ID to cancel
         * @param {CancelOrderRequest} cancelOrderRequest cancel an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(id: string, cancelOrderRequest: CancelOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CancelOrderResponse> {
            return localVarFp.cancelOrder(id, cancelOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create collection
         * @summary Create collection
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateCollectionRequest} createCollectionRequest create a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(iMXSignature: string, iMXTimestamp: string, createCollectionRequest: CreateCollectionRequest, options?: any): AxiosPromise<Collection> {
            return localVarFp.createCollection(iMXSignature, iMXTimestamp, createCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an order
         * @summary Create an order
         * @param {CreateOrderRequest} createOrderRequest create an order
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest: CreateOrderRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateOrderResponse> {
            return localVarFp.createOrder(createOrderRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a project
         * @summary Create a project
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {CreateProjectRequest} createProjectRequest create a project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(iMXSignature: string, iMXTimestamp: string, createProjectRequest: CreateProjectRequest, options?: any): AxiosPromise<CreateProjectResponse> {
            return localVarFp.createProject(iMXSignature, iMXTimestamp, createProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Trade
         * @summary Create a Trade between two parties
         * @param {CreateTradeRequestV1} createTradeRequest create a trade
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade(createTradeRequest: CreateTradeRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateTradeResponse> {
            return localVarFp.createTrade(createTradeRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of multiple tokens between two parties
         * @param {CreateTransferRequest} createTransferRequestV2 Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(createTransferRequestV2: CreateTransferRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateTransferResponse> {
            return localVarFp.createTransfer(createTransferRequestV2, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer request
         * @summary Creates a transfer of tokens between two parties
         * @param {CreateTransferRequestV1} createTransferRequest Create transfer
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferV1(createTransferRequest: CreateTransferRequestV1, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateTransferResponseV1> {
            return localVarFp.createTransferV1(createTransferRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a withdrawal
         * @summary Creates a withdrawal of a token
         * @param {CreateWithdrawalRequest} createWithdrawalRequest create a withdrawal
         * @param {string} [xImxEthAddress] eth address
         * @param {string} [xImxEthSignature] eth signature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, xImxEthAddress?: string, xImxEthSignature?: string, options?: any): AxiosPromise<CreateWithdrawalResponse> {
            return localVarFp.createWithdrawal(createWithdrawalRequest, xImxEthAddress, xImxEthSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an asset
         * @summary Get details of an asset
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId Either ERC721 token ID or internal IMX ID
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(tokenAddress: string, tokenId: string, includeFees?: boolean, options?: any): AxiosPromise<Asset> {
            return localVarFp.getAsset(tokenAddress, tokenId, includeFees, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the token balances of the user
         * @summary Fetches the token balances of the user
         * @param {string} owner Address of the owner/user
         * @param {string} address Token address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(owner: string, address: string, options?: any): AxiosPromise<GetBalanceResponse> {
            return localVarFp.getBalance(owner, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a collection at the given address
         * @summary Get details of a collection at the given address
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(address: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.getCollection(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a deposit with the given ID
         * @summary Get details of a deposit with the given ID
         * @param {string} id Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeposit(id: string, options?: any): AxiosPromise<Deposit> {
            return localVarFp.getDeposit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get collection metadata schema
         * @summary Get collection metadata schema
         * @param {string} address Collection contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSchema(address: string, options?: any): AxiosPromise<Array<MetadataSchemaProperty>> {
            return localVarFp.getMetadataSchema(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a mint with the given ID
         * @summary Get details of a mint with the given ID
         * @param {string} id Mint ID. This is the transaction_id returned from listMints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMint(id: string, options?: any): AxiosPromise<Mint> {
            return localVarFp.getMint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a mintable token with the given token address and token ID
         * @summary Get details of a mintable token with the given token address and token ID
         * @param {string} tokenAddress Address of the ERC721 contract
         * @param {string} tokenId ERC721 token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMintableTokenDetailsByClientTokenId(tokenAddress: string, tokenId: string, options?: any): AxiosPromise<MintableTokenDetails> {
            return localVarFp.getMintableTokenDetailsByClientTokenId(tokenAddress, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an order with the given ID
         * @summary Get details of an order with the given ID
         * @param {string} id Order ID
         * @param {boolean} [includeFees] Set flag to true to include fee body for the order
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(id: string, includeFees?: boolean, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrder(id, includeFees, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project
         * @summary Get a project
         * @param {string} id Project ID
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: string, iMXSignature: string, iMXTimestamp: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(id, iMXSignature, iMXTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Get projects
         * @summary Get projects
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(iMXSignature: string, iMXTimestamp: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, options?: any): AxiosPromise<GetProjectsResponse> {
            return localVarFp.getProjects(iMXSignature, iMXTimestamp, pageSize, cursor, orderBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable cancel order
         * @summary Get details a signable cancel order
         * @param {GetSignableCancelOrderRequest} getSignableCancelOrderRequest get a signable cancel order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableCancelOrder(getSignableCancelOrderRequest: GetSignableCancelOrderRequest, options?: any): AxiosPromise<GetSignableCancelOrderResponse> {
            return localVarFp.getSignableCancelOrder(getSignableCancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable deposit
         * @summary Gets details of a signable deposit
         * @param {GetSignableDepositRequest} getSignableDepositRequest Get details of signable deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableDeposit(getSignableDepositRequest: GetSignableDepositRequest, options?: any): AxiosPromise<GetSignableDepositResponse> {
            return localVarFp.getSignableDeposit(getSignableDepositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable order V3
         * @summary Get details a signable order V3
         * @param {GetSignableOrderRequest} getSignableOrderRequestV3 get a signable order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableOrder(getSignableOrderRequestV3: GetSignableOrderRequest, options?: any): AxiosPromise<GetSignableOrderResponse> {
            return localVarFp.getSignableOrder(getSignableOrderRequestV3, options).then((request) => request(axios, basePath));
        },
        /**
         * Get operator signature to allow clients to register the user
         * @summary Get operator signature to allow clients to register the user
         * @param {GetSignableRegistrationRequest} getSignableRegistrationRequest Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableRegistration(getSignableRegistrationRequest: GetSignableRegistrationRequest, options?: any): AxiosPromise<GetSignableRegistrationResponse> {
            return localVarFp.getSignableRegistration(getSignableRegistrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details a signable trade V3
         * @summary Get details a signable trade V3
         * @param {GetSignableTradeRequest} getSignableTradeRequest get a signable trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTrade(getSignableTradeRequest: GetSignableTradeRequest, options?: any): AxiosPromise<GetSignableTradeResponse> {
            return localVarFp.getSignableTrade(getSignableTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets bulk details of a signable transfer
         * @summary Gets bulk details of a signable transfer
         * @param {GetSignableTransferRequest} getSignableTransferRequestV2 get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransfer(getSignableTransferRequestV2: GetSignableTransferRequest, options?: any): AxiosPromise<GetSignableTransferResponse> {
            return localVarFp.getSignableTransfer(getSignableTransferRequestV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable transfer
         * @summary Gets details of a signable transfer
         * @param {GetSignableTransferRequestV1} getSignableTransferRequest get details of signable transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableTransferV1(getSignableTransferRequest: GetSignableTransferRequestV1, options?: any): AxiosPromise<GetSignableTransferResponseV1> {
            return localVarFp.getSignableTransferV1(getSignableTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of a signable withdrawal
         * @summary Gets details of a signable withdrawal
         * @param {GetSignableWithdrawalRequest} getSignableWithdrawalRequest get details of signable withdrawal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignableWithdrawal(getSignableWithdrawalRequest: GetSignableWithdrawalRequest, options?: any): AxiosPromise<GetSignableWithdrawalResponse> {
            return localVarFp.getSignableWithdrawal(getSignableWithdrawalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a token
         * @summary Get details of a token
         * @param {string} address Token Contract Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(address: string, options?: any): AxiosPromise<TokenDetails> {
            return localVarFp.getToken(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a trade with the given ID
         * @summary Get details of a trade with the given ID
         * @param {string} id Trade ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(id: string, options?: any): AxiosPromise<Trade> {
            return localVarFp.getTrade(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a transfer with the given ID
         * @summary Get details of a transfer with the given ID
         * @param {string} id Transfer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(id: string, options?: any): AxiosPromise<Transfer> {
            return localVarFp.getTransfer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stark keys for a registered user
         * @summary Get stark keys for a registered user
         * @param {string} user User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(user: string, options?: any): AxiosPromise<GetUsersApiResponse> {
            return localVarFp.getUsers(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets details of withdrawal with the given ID
         * @summary Gets details of withdrawal with the given ID
         * @param {string} id Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawal(id: string, options?: any): AxiosPromise<Withdrawal> {
            return localVarFp.getWithdrawal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of assets
         * @summary Get a list of assets
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'updated_at' | 'name'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who owns these assets
         * @param {string} [status] Status of these assets
         * @param {string} [name] Name of the asset to search
         * @param {string} [metadata] JSON-encoded metadata filters for these asset. Example: {
         * @param {boolean} [sellOrders] Set flag to true to fetch an array of sell order details with accepted status associated with the asset
         * @param {boolean} [buyOrders] Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
         * @param {boolean} [includeFees] Set flag to include fees associated with the asset
         * @param {string} [collection] Collection contract address
         * @param {string} [updatedMinTimestamp] Minimum timestamp for when these assets were last updated
         * @param {string} [updatedMaxTimestamp] Maximum timestamp for when these assets were last updated
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssets(pageSize?: number, cursor?: string, orderBy?: 'updated_at' | 'name', direction?: string, user?: string, status?: string, name?: string, metadata?: string, sellOrders?: boolean, buyOrders?: boolean, includeFees?: boolean, collection?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ListAssetsResponse> {
            return localVarFp.listAssets(pageSize, cursor, orderBy, direction, user, status, name, metadata, sellOrders, buyOrders, includeFees, collection, updatedMinTimestamp, updatedMaxTimestamp, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of balances for given user
         * @summary Get a list of balances for given user
         * @param {string} owner Ethereum wallet address for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances(owner: string, options?: any): AxiosPromise<ListBalancesResponse> {
            return localVarFp.listBalances(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of collection filters
         * @summary Get a list of collection filters
         * @param {string} address Collection contract address
         * @param {number} [pageSize] Page size of the result
         * @param {string} [nextPageToken] Next page token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionFilters(address: string, pageSize?: number, nextPageToken?: string, options?: any): AxiosPromise<CollectionFilter> {
            return localVarFp.listCollectionFilters(address, pageSize, nextPageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of collections
         * @summary Get a list of collections
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [blacklist] List of collections not to be displayed, separated by commas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, blacklist?: string, options?: any): AxiosPromise<ListCollectionsResponse> {
            return localVarFp.listCollections(pageSize, cursor, orderBy, direction, blacklist, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of deposits
         * @summary Get a list of deposits
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this deposit
         * @param {string} [status] Status of this deposit
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the deposited asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the deposited asset
         * @param {string} [tokenName] Token name of the deposited asset
         * @param {string} [minQuantity] Min quantity for the deposited asset
         * @param {string} [maxQuantity] Max quantity for the deposited asset
         * @param {string} [metadata] JSON-encoded metadata filters for the deposited asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeposits(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListDepositsResponse> {
            return localVarFp.listDeposits(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of mints
         * @summary Get a list of mints
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this mint
         * @param {string} [status] Status of this mint
         * @param {string} [minTimestamp] Minimum timestamp for this mint
         * @param {string} [maxTimestamp] Maximum timestamp for this mint
         * @param {string} [tokenType] Token type of the minted asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenName] Token Name of the minted asset
         * @param {string} [tokenAddress] Token address of the minted asset
         * @param {string} [minQuantity] Min quantity for the minted asset
         * @param {string} [maxQuantity] Max quantity for the minted asset
         * @param {string} [metadata] JSON-encoded metadata filters for the minted asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMints(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenName?: string, tokenAddress?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListMintsResponse> {
            return localVarFp.listMints(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenName, tokenAddress, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of orders
         * @summary Get a list of orders
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this order
         * @param {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'} [status] Status of this order
         * @param {string} [minTimestamp] Minimum created at timestamp for this order
         * @param {string} [maxTimestamp] Maximum created at timestamp for this order
         * @param {string} [updatedMinTimestamp] Minimum updated at timestamp for this order
         * @param {string} [updatedMaxTimestamp] Maximum updated at timestamp for this order
         * @param {string} [buyTokenType] Token type of the asset this order buys
         * @param {string} [buyTokenId] ERC721 Token ID of the asset this order buys
         * @param {string} [buyAssetId] Internal IMX ID of the asset this order buys
         * @param {string} [buyTokenAddress] Comma separated string of token addresses of the asset this order buys
         * @param {string} [buyTokenName] Token name of the asset this order buys
         * @param {string} [buyMinQuantity] Min quantity for the asset this order buys
         * @param {string} [buyMaxQuantity] Max quantity for the asset this order buys
         * @param {string} [buyMetadata] JSON-encoded metadata filters for the asset this order buys
         * @param {string} [sellTokenType] Token type of the asset this order sells
         * @param {string} [sellTokenId] ERC721 Token ID of the asset this order sells
         * @param {string} [sellAssetId] Internal IMX ID of the asset this order sells
         * @param {string} [sellTokenAddress] Comma separated string of token addresses of the asset this order sells
         * @param {string} [sellTokenName] Token name of the asset this order sells
         * @param {string} [sellMinQuantity] Min quantity for the asset this order sells
         * @param {string} [sellMaxQuantity] Max quantity for the asset this order sells
         * @param {string} [sellMetadata] JSON-encoded metadata filters for the asset this order sells
         * @param {string} [auxiliaryFeePercentages] Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
         * @param {string} [auxiliaryFeeRecipients] Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(pageSize?: number, cursor?: string, orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at', direction?: string, user?: string, status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive', minTimestamp?: string, maxTimestamp?: string, updatedMinTimestamp?: string, updatedMaxTimestamp?: string, buyTokenType?: string, buyTokenId?: string, buyAssetId?: string, buyTokenAddress?: string, buyTokenName?: string, buyMinQuantity?: string, buyMaxQuantity?: string, buyMetadata?: string, sellTokenType?: string, sellTokenId?: string, sellAssetId?: string, sellTokenAddress?: string, sellTokenName?: string, sellMinQuantity?: string, sellMaxQuantity?: string, sellMetadata?: string, auxiliaryFeePercentages?: string, auxiliaryFeeRecipients?: string, options?: any): AxiosPromise<ListOrdersResponse> {
            return localVarFp.listOrders(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, updatedMinTimestamp, updatedMaxTimestamp, buyTokenType, buyTokenId, buyAssetId, buyTokenAddress, buyTokenName, buyMinQuantity, buyMaxQuantity, buyMetadata, sellTokenType, sellTokenId, sellAssetId, sellTokenAddress, sellTokenName, sellMinQuantity, sellMaxQuantity, sellMetadata, auxiliaryFeePercentages, auxiliaryFeeRecipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tokens
         * @summary Get a list of tokens
         * @param {string} [address] Contract address of the token
         * @param {string} [symbols] Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(address?: string, symbols?: string, options?: any): AxiosPromise<ListTokensResponse> {
            return localVarFp.listTokens(address, symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of trades
         * @summary Get a list of trades
         * @param {string} [partyATokenType] Party A\&#39;s sell token type
         * @param {string} [partyATokenAddress] Party A\&#39;s sell token address
         * @param {string} [partyATokenId] Party A\&#39;s sell token id
         * @param {string} [partyBTokenType] Party B\&#39;s sell token type
         * @param {string} [partyBTokenAddress] Party B\&#39;s sell token address
         * @param {string} [partyBTokenId] Party B\&#39;s sell token id
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [minTimestamp] Minimum timestamp for this trade
         * @param {string} [maxTimestamp] Maximum timestamp for this trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(partyATokenType?: string, partyATokenAddress?: string, partyATokenId?: string, partyBTokenType?: string, partyBTokenAddress?: string, partyBTokenId?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, minTimestamp?: string, maxTimestamp?: string, options?: any): AxiosPromise<ListTradesResponse> {
            return localVarFp.listTrades(partyATokenType, partyATokenAddress, partyATokenId, partyBTokenType, partyBTokenAddress, partyBTokenId, pageSize, cursor, orderBy, direction, minTimestamp, maxTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of transfers
         * @summary Get a list of transfers
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this transfer
         * @param {'success' | 'failure'} [status] Status of this transfer
         * @param {string} [minTimestamp] Minimum timestamp for this transfer
         * @param {string} [maxTimestamp] Maximum timestamp for this transfer
         * @param {string} [tokenType] Token type of the transferred asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the transferred asset
         * @param {string} [tokenName] Token name of the transferred asset
         * @param {string} [minQuantity] Max quantity for the transferred asset
         * @param {string} [maxQuantity] Max quantity for the transferred asset
         * @param {string} [metadata] JSON-encoded metadata filters for the transferred asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: 'success' | 'failure', minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListTransfersResponse> {
            return localVarFp.listTransfers(pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of withdrawals
         * @summary Get a list of withdrawals
         * @param {boolean} [withdrawnToWallet] Withdrawal has been transferred to user\&#39;s Layer 1 wallet
         * @param {string} [rollupStatus] Status of the on-chain batch confirmation for this withdrawal
         * @param {number} [pageSize] Page size of the result
         * @param {string} [cursor] Cursor
         * @param {string} [orderBy] Property to sort by
         * @param {string} [direction] Direction to sort (asc/desc)
         * @param {string} [user] Ethereum address of the user who submitted this withdrawal
         * @param {string} [status] Status of this withdrawal
         * @param {string} [minTimestamp] Minimum timestamp for this deposit
         * @param {string} [maxTimestamp] Maximum timestamp for this deposit
         * @param {string} [tokenType] Token type of the withdrawn asset
         * @param {string} [tokenId] ERC721 Token ID of the minted asset
         * @param {string} [assetId] Internal IMX ID of the minted asset
         * @param {string} [tokenAddress] Token address of the withdrawn asset
         * @param {string} [tokenName] Token name of the withdrawn asset
         * @param {string} [minQuantity] Min quantity for the withdrawn asset
         * @param {string} [maxQuantity] Max quantity for the withdrawn asset
         * @param {string} [metadata] JSON-encoded metadata filters for the withdrawn asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWithdrawals(withdrawnToWallet?: boolean, rollupStatus?: string, pageSize?: number, cursor?: string, orderBy?: string, direction?: string, user?: string, status?: string, minTimestamp?: string, maxTimestamp?: string, tokenType?: string, tokenId?: string, assetId?: string, tokenAddress?: string, tokenName?: string, minQuantity?: string, maxQuantity?: string, metadata?: string, options?: any): AxiosPromise<ListWithdrawalsResponse> {
            return localVarFp.listWithdrawals(withdrawnToWallet, rollupStatus, pageSize, cursor, orderBy, direction, user, status, minTimestamp, maxTimestamp, tokenType, tokenId, assetId, tokenAddress, tokenName, minQuantity, maxQuantity, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Mint tokens in a batch with fees
         * @summary Mint Tokens V2
         * @param {Array<MintRequest>} mintTokensRequestV2 details of tokens to mint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintTokens(mintTokensRequestV2: Array<MintRequest>, options?: any): AxiosPromise<MintTokensResponse> {
            return localVarFp.mintTokens(mintTokensRequestV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a user
         * @summary Registers a user
         * @param {RegisterUserRequestVerifyEth} registerUserRequestVerifyEth Register User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequestVerifyEth: RegisterUserRequestVerifyEth, options?: any): AxiosPromise<RegisterUserResponse> {
            return localVarFp.registerUser(registerUserRequestVerifyEth, options).then((request) => request(axios, basePath));
        },
        /**
         * Update collection
         * @summary Update collection
         * @param {string} address Collection contract address
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {UpdateCollectionRequest} updateCollectionRequest update a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(address: string, iMXSignature: string, iMXTimestamp: string, updateCollectionRequest: UpdateCollectionRequest, options?: any): AxiosPromise<Collection> {
            return localVarFp.updateCollection(address, iMXSignature, iMXTimestamp, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update metadata schema by name
         * @summary Update metadata schema by name
         * @param {string} address Collection contract address
         * @param {string} name Metadata schema name
         * @param {string} iMXSignature String created by signing wallet address and timestamp
         * @param {string} iMXTimestamp Unix Epoc timestamp
         * @param {MetadataSchemaRequest} metadataSchemaRequest update metadata schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataSchemaByName(address: string, name: string, iMXSignature: string, iMXTimestamp: string, metadataSchemaRequest: MetadataSchemaRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.updateMetadataSchemaByName(address, name, iMXSignature, iMXTimestamp, metadataSchemaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addMetadataSchemaToCollection operation in PublicApi.
 * @export
 * @interface PublicApiAddMetadataSchemaToCollectionRequest
 */
export interface PublicApiAddMetadataSchemaToCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiAddMetadataSchemaToCollection
     */
    readonly address: string

    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiAddMetadataSchemaToCollection
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiAddMetadataSchemaToCollection
     */
    readonly iMXTimestamp: string

    /**
     * add metadata schema to a collection
     * @type {AddMetadataSchemaToCollectionRequest}
     * @memberof PublicApiAddMetadataSchemaToCollection
     */
    readonly addMetadataSchemaToCollectionRequest: AddMetadataSchemaToCollectionRequest
}

/**
 * Request parameters for cancelOrder operation in PublicApi.
 * @export
 * @interface PublicApiCancelOrderRequest
 */
export interface PublicApiCancelOrderRequest {
    /**
     * Order ID to cancel
     * @type {string}
     * @memberof PublicApiCancelOrder
     */
    readonly id: string

    /**
     * cancel an order
     * @type {CancelOrderRequest}
     * @memberof PublicApiCancelOrder
     */
    readonly cancelOrderRequest: CancelOrderRequest

    /**
     * eth address
     * @type {string}
     * @memberof PublicApiCancelOrder
     */
    readonly xImxEthAddress?: string

    /**
     * eth signature
     * @type {string}
     * @memberof PublicApiCancelOrder
     */
    readonly xImxEthSignature?: string
}

/**
 * Request parameters for createCollection operation in PublicApi.
 * @export
 * @interface PublicApiCreateCollectionRequest
 */
export interface PublicApiCreateCollectionRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiCreateCollection
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiCreateCollection
     */
    readonly iMXTimestamp: string

    /**
     * create a collection
     * @type {CreateCollectionRequest}
     * @memberof PublicApiCreateCollection
     */
    readonly createCollectionRequest: CreateCollectionRequest
}

/**
 * Request parameters for createOrder operation in PublicApi.
 * @export
 * @interface PublicApiCreateOrderRequest
 */
export interface PublicApiCreateOrderRequest {
    /**
     * create an order
     * @type {CreateOrderRequest}
     * @memberof PublicApiCreateOrder
     */
    readonly createOrderRequest: CreateOrderRequest

    /**
     * eth address
     * @type {string}
     * @memberof PublicApiCreateOrder
     */
    readonly xImxEthAddress?: string

    /**
     * eth signature
     * @type {string}
     * @memberof PublicApiCreateOrder
     */
    readonly xImxEthSignature?: string
}

/**
 * Request parameters for createProject operation in PublicApi.
 * @export
 * @interface PublicApiCreateProjectRequest
 */
export interface PublicApiCreateProjectRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiCreateProject
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiCreateProject
     */
    readonly iMXTimestamp: string

    /**
     * create a project
     * @type {CreateProjectRequest}
     * @memberof PublicApiCreateProject
     */
    readonly createProjectRequest: CreateProjectRequest
}

/**
 * Request parameters for createTrade operation in PublicApi.
 * @export
 * @interface PublicApiCreateTradeRequest
 */
export interface PublicApiCreateTradeRequest {
    /**
     * create a trade
     * @type {CreateTradeRequestV1}
     * @memberof PublicApiCreateTrade
     */
    readonly createTradeRequest: CreateTradeRequestV1

    /**
     * eth address
     * @type {string}
     * @memberof PublicApiCreateTrade
     */
    readonly xImxEthAddress?: string

    /**
     * eth signature
     * @type {string}
     * @memberof PublicApiCreateTrade
     */
    readonly xImxEthSignature?: string
}

/**
 * Request parameters for createTransfer operation in PublicApi.
 * @export
 * @interface PublicApiCreateTransferRequest
 */
export interface PublicApiCreateTransferRequest {
    /**
     * Create transfer
     * @type {CreateTransferRequest}
     * @memberof PublicApiCreateTransfer
     */
    readonly createTransferRequestV2: CreateTransferRequest

    /**
     * eth address
     * @type {string}
     * @memberof PublicApiCreateTransfer
     */
    readonly xImxEthAddress?: string

    /**
     * eth signature
     * @type {string}
     * @memberof PublicApiCreateTransfer
     */
    readonly xImxEthSignature?: string
}

/**
 * Request parameters for createTransferV1 operation in PublicApi.
 * @export
 * @interface PublicApiCreateTransferV1Request
 */
export interface PublicApiCreateTransferV1Request {
    /**
     * Create transfer
     * @type {CreateTransferRequestV1}
     * @memberof PublicApiCreateTransferV1
     */
    readonly createTransferRequest: CreateTransferRequestV1

    /**
     * eth address
     * @type {string}
     * @memberof PublicApiCreateTransferV1
     */
    readonly xImxEthAddress?: string

    /**
     * eth signature
     * @type {string}
     * @memberof PublicApiCreateTransferV1
     */
    readonly xImxEthSignature?: string
}

/**
 * Request parameters for createWithdrawal operation in PublicApi.
 * @export
 * @interface PublicApiCreateWithdrawalRequest
 */
export interface PublicApiCreateWithdrawalRequest {
    /**
     * create a withdrawal
     * @type {CreateWithdrawalRequest}
     * @memberof PublicApiCreateWithdrawal
     */
    readonly createWithdrawalRequest: CreateWithdrawalRequest

    /**
     * eth address
     * @type {string}
     * @memberof PublicApiCreateWithdrawal
     */
    readonly xImxEthAddress?: string

    /**
     * eth signature
     * @type {string}
     * @memberof PublicApiCreateWithdrawal
     */
    readonly xImxEthSignature?: string
}

/**
 * Request parameters for getAsset operation in PublicApi.
 * @export
 * @interface PublicApiGetAssetRequest
 */
export interface PublicApiGetAssetRequest {
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof PublicApiGetAsset
     */
    readonly tokenAddress: string

    /**
     * Either ERC721 token ID or internal IMX ID
     * @type {string}
     * @memberof PublicApiGetAsset
     */
    readonly tokenId: string

    /**
     * Set flag to include fees associated with the asset
     * @type {boolean}
     * @memberof PublicApiGetAsset
     */
    readonly includeFees?: boolean
}

/**
 * Request parameters for getBalance operation in PublicApi.
 * @export
 * @interface PublicApiGetBalanceRequest
 */
export interface PublicApiGetBalanceRequest {
    /**
     * Address of the owner/user
     * @type {string}
     * @memberof PublicApiGetBalance
     */
    readonly owner: string

    /**
     * Token address
     * @type {string}
     * @memberof PublicApiGetBalance
     */
    readonly address: string
}

/**
 * Request parameters for getCollection operation in PublicApi.
 * @export
 * @interface PublicApiGetCollectionRequest
 */
export interface PublicApiGetCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiGetCollection
     */
    readonly address: string
}

/**
 * Request parameters for getDeposit operation in PublicApi.
 * @export
 * @interface PublicApiGetDepositRequest
 */
export interface PublicApiGetDepositRequest {
    /**
     * Deposit ID
     * @type {string}
     * @memberof PublicApiGetDeposit
     */
    readonly id: string
}

/**
 * Request parameters for getMetadataSchema operation in PublicApi.
 * @export
 * @interface PublicApiGetMetadataSchemaRequest
 */
export interface PublicApiGetMetadataSchemaRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiGetMetadataSchema
     */
    readonly address: string
}

/**
 * Request parameters for getMint operation in PublicApi.
 * @export
 * @interface PublicApiGetMintRequest
 */
export interface PublicApiGetMintRequest {
    /**
     * Mint ID. This is the transaction_id returned from listMints
     * @type {string}
     * @memberof PublicApiGetMint
     */
    readonly id: string
}

/**
 * Request parameters for getMintableTokenDetailsByClientTokenId operation in PublicApi.
 * @export
 * @interface PublicApiGetMintableTokenDetailsByClientTokenIdRequest
 */
export interface PublicApiGetMintableTokenDetailsByClientTokenIdRequest {
    /**
     * Address of the ERC721 contract
     * @type {string}
     * @memberof PublicApiGetMintableTokenDetailsByClientTokenId
     */
    readonly tokenAddress: string

    /**
     * ERC721 token ID
     * @type {string}
     * @memberof PublicApiGetMintableTokenDetailsByClientTokenId
     */
    readonly tokenId: string
}

/**
 * Request parameters for getOrder operation in PublicApi.
 * @export
 * @interface PublicApiGetOrderRequest
 */
export interface PublicApiGetOrderRequest {
    /**
     * Order ID
     * @type {string}
     * @memberof PublicApiGetOrder
     */
    readonly id: string

    /**
     * Set flag to true to include fee body for the order
     * @type {boolean}
     * @memberof PublicApiGetOrder
     */
    readonly includeFees?: boolean

    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof PublicApiGetOrder
     */
    readonly auxiliaryFeePercentages?: string

    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof PublicApiGetOrder
     */
    readonly auxiliaryFeeRecipients?: string
}

/**
 * Request parameters for getProject operation in PublicApi.
 * @export
 * @interface PublicApiGetProjectRequest
 */
export interface PublicApiGetProjectRequest {
    /**
     * Project ID
     * @type {string}
     * @memberof PublicApiGetProject
     */
    readonly id: string

    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiGetProject
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiGetProject
     */
    readonly iMXTimestamp: string
}

/**
 * Request parameters for getProjects operation in PublicApi.
 * @export
 * @interface PublicApiGetProjectsRequest
 */
export interface PublicApiGetProjectsRequest {
    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiGetProjects
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiGetProjects
     */
    readonly iMXTimestamp: string

    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiGetProjects
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiGetProjects
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiGetProjects
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiGetProjects
     */
    readonly direction?: string
}

/**
 * Request parameters for getSignableCancelOrder operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableCancelOrderRequest
 */
export interface PublicApiGetSignableCancelOrderRequest {
    /**
     * get a signable cancel order
     * @type {GetSignableCancelOrderRequest}
     * @memberof PublicApiGetSignableCancelOrder
     */
    readonly getSignableCancelOrderRequest: GetSignableCancelOrderRequest
}

/**
 * Request parameters for getSignableDeposit operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableDepositRequest
 */
export interface PublicApiGetSignableDepositRequest {
    /**
     * Get details of signable deposit
     * @type {GetSignableDepositRequest}
     * @memberof PublicApiGetSignableDeposit
     */
    readonly getSignableDepositRequest: GetSignableDepositRequest
}

/**
 * Request parameters for getSignableOrder operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableOrderRequest
 */
export interface PublicApiGetSignableOrderRequest {
    /**
     * get a signable order
     * @type {GetSignableOrderRequest}
     * @memberof PublicApiGetSignableOrder
     */
    readonly getSignableOrderRequestV3: GetSignableOrderRequest
}

/**
 * Request parameters for getSignableRegistration operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableRegistrationRequest
 */
export interface PublicApiGetSignableRegistrationRequest {
    /**
     * Register User
     * @type {GetSignableRegistrationRequest}
     * @memberof PublicApiGetSignableRegistration
     */
    readonly getSignableRegistrationRequest: GetSignableRegistrationRequest
}

/**
 * Request parameters for getSignableTrade operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableTradeRequest
 */
export interface PublicApiGetSignableTradeRequest {
    /**
     * get a signable trade
     * @type {GetSignableTradeRequest}
     * @memberof PublicApiGetSignableTrade
     */
    readonly getSignableTradeRequest: GetSignableTradeRequest
}

/**
 * Request parameters for getSignableTransfer operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableTransferRequest
 */
export interface PublicApiGetSignableTransferRequest {
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequest}
     * @memberof PublicApiGetSignableTransfer
     */
    readonly getSignableTransferRequestV2: GetSignableTransferRequest
}

/**
 * Request parameters for getSignableTransferV1 operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableTransferV1Request
 */
export interface PublicApiGetSignableTransferV1Request {
    /**
     * get details of signable transfer
     * @type {GetSignableTransferRequestV1}
     * @memberof PublicApiGetSignableTransferV1
     */
    readonly getSignableTransferRequest: GetSignableTransferRequestV1
}

/**
 * Request parameters for getSignableWithdrawal operation in PublicApi.
 * @export
 * @interface PublicApiGetSignableWithdrawalRequest
 */
export interface PublicApiGetSignableWithdrawalRequest {
    /**
     * get details of signable withdrawal
     * @type {GetSignableWithdrawalRequest}
     * @memberof PublicApiGetSignableWithdrawal
     */
    readonly getSignableWithdrawalRequest: GetSignableWithdrawalRequest
}

/**
 * Request parameters for getToken operation in PublicApi.
 * @export
 * @interface PublicApiGetTokenRequest
 */
export interface PublicApiGetTokenRequest {
    /**
     * Token Contract Address
     * @type {string}
     * @memberof PublicApiGetToken
     */
    readonly address: string
}

/**
 * Request parameters for getTrade operation in PublicApi.
 * @export
 * @interface PublicApiGetTradeRequest
 */
export interface PublicApiGetTradeRequest {
    /**
     * Trade ID
     * @type {string}
     * @memberof PublicApiGetTrade
     */
    readonly id: string
}

/**
 * Request parameters for getTransfer operation in PublicApi.
 * @export
 * @interface PublicApiGetTransferRequest
 */
export interface PublicApiGetTransferRequest {
    /**
     * Transfer ID
     * @type {string}
     * @memberof PublicApiGetTransfer
     */
    readonly id: string
}

/**
 * Request parameters for getUsers operation in PublicApi.
 * @export
 * @interface PublicApiGetUsersRequest
 */
export interface PublicApiGetUsersRequest {
    /**
     * User
     * @type {string}
     * @memberof PublicApiGetUsers
     */
    readonly user: string
}

/**
 * Request parameters for getWithdrawal operation in PublicApi.
 * @export
 * @interface PublicApiGetWithdrawalRequest
 */
export interface PublicApiGetWithdrawalRequest {
    /**
     * Withdrawal ID
     * @type {string}
     * @memberof PublicApiGetWithdrawal
     */
    readonly id: string
}

/**
 * Request parameters for listAssets operation in PublicApi.
 * @export
 * @interface PublicApiListAssetsRequest
 */
export interface PublicApiListAssetsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListAssets
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {'updated_at' | 'name'}
     * @memberof PublicApiListAssets
     */
    readonly orderBy?: 'updated_at' | 'name'

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly direction?: string

    /**
     * Ethereum address of the user who owns these assets
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly user?: string

    /**
     * Status of these assets
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly status?: string

    /**
     * Name of the asset to search
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly name?: string

    /**
     * JSON-encoded metadata filters for these asset. Example: {
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly metadata?: string

    /**
     * Set flag to true to fetch an array of sell order details with accepted status associated with the asset
     * @type {boolean}
     * @memberof PublicApiListAssets
     */
    readonly sellOrders?: boolean

    /**
     * Set flag to true to fetch an array of buy order details  with accepted status associated with the asset
     * @type {boolean}
     * @memberof PublicApiListAssets
     */
    readonly buyOrders?: boolean

    /**
     * Set flag to include fees associated with the asset
     * @type {boolean}
     * @memberof PublicApiListAssets
     */
    readonly includeFees?: boolean

    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly collection?: string

    /**
     * Minimum timestamp for when these assets were last updated
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly updatedMinTimestamp?: string

    /**
     * Maximum timestamp for when these assets were last updated
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly updatedMaxTimestamp?: string

    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly auxiliaryFeePercentages?: string

    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof PublicApiListAssets
     */
    readonly auxiliaryFeeRecipients?: string
}

/**
 * Request parameters for listBalances operation in PublicApi.
 * @export
 * @interface PublicApiListBalancesRequest
 */
export interface PublicApiListBalancesRequest {
    /**
     * Ethereum wallet address for user
     * @type {string}
     * @memberof PublicApiListBalances
     */
    readonly owner: string
}

/**
 * Request parameters for listCollectionFilters operation in PublicApi.
 * @export
 * @interface PublicApiListCollectionFiltersRequest
 */
export interface PublicApiListCollectionFiltersRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiListCollectionFilters
     */
    readonly address: string

    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListCollectionFilters
     */
    readonly pageSize?: number

    /**
     * Next page token
     * @type {string}
     * @memberof PublicApiListCollectionFilters
     */
    readonly nextPageToken?: string
}

/**
 * Request parameters for listCollections operation in PublicApi.
 * @export
 * @interface PublicApiListCollectionsRequest
 */
export interface PublicApiListCollectionsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListCollections
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListCollections
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiListCollections
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListCollections
     */
    readonly direction?: string

    /**
     * List of collections not to be displayed, separated by commas
     * @type {string}
     * @memberof PublicApiListCollections
     */
    readonly blacklist?: string
}

/**
 * Request parameters for listDeposits operation in PublicApi.
 * @export
 * @interface PublicApiListDepositsRequest
 */
export interface PublicApiListDepositsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListDeposits
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly direction?: string

    /**
     * Ethereum address of the user who submitted this deposit
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly user?: string

    /**
     * Status of this deposit
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly status?: string

    /**
     * Minimum timestamp for this deposit
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly minTimestamp?: string

    /**
     * Maximum timestamp for this deposit
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly maxTimestamp?: string

    /**
     * Token type of the deposited asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly tokenType?: string

    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly tokenId?: string

    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly assetId?: string

    /**
     * Token address of the deposited asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly tokenAddress?: string

    /**
     * Token name of the deposited asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly tokenName?: string

    /**
     * Min quantity for the deposited asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly minQuantity?: string

    /**
     * Max quantity for the deposited asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly maxQuantity?: string

    /**
     * JSON-encoded metadata filters for the deposited asset
     * @type {string}
     * @memberof PublicApiListDeposits
     */
    readonly metadata?: string
}

/**
 * Request parameters for listMints operation in PublicApi.
 * @export
 * @interface PublicApiListMintsRequest
 */
export interface PublicApiListMintsRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListMints
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly direction?: string

    /**
     * Ethereum address of the user who submitted this mint
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly user?: string

    /**
     * Status of this mint
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly status?: string

    /**
     * Minimum timestamp for this mint
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly minTimestamp?: string

    /**
     * Maximum timestamp for this mint
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly maxTimestamp?: string

    /**
     * Token type of the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly tokenType?: string

    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly tokenId?: string

    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly assetId?: string

    /**
     * Token Name of the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly tokenName?: string

    /**
     * Token address of the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly tokenAddress?: string

    /**
     * Min quantity for the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly minQuantity?: string

    /**
     * Max quantity for the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly maxQuantity?: string

    /**
     * JSON-encoded metadata filters for the minted asset
     * @type {string}
     * @memberof PublicApiListMints
     */
    readonly metadata?: string
}

/**
 * Request parameters for listOrders operation in PublicApi.
 * @export
 * @interface PublicApiListOrdersRequest
 */
export interface PublicApiListOrdersRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListOrders
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'}
     * @memberof PublicApiListOrders
     */
    readonly orderBy?: 'created_at' | 'expired_at' | 'sell_quantity' | 'buy_quantity' | 'updated_at'

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly direction?: string

    /**
     * Ethereum address of the user who submitted this order
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly user?: string

    /**
     * Status of this order
     * @type {'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'}
     * @memberof PublicApiListOrders
     */
    readonly status?: 'active' | 'filled' | 'cancelled' | 'expired' | 'inactive'

    /**
     * Minimum created at timestamp for this order
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly minTimestamp?: string

    /**
     * Maximum created at timestamp for this order
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly maxTimestamp?: string

    /**
     * Minimum updated at timestamp for this order
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly updatedMinTimestamp?: string

    /**
     * Maximum updated at timestamp for this order
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly updatedMaxTimestamp?: string

    /**
     * Token type of the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyTokenType?: string

    /**
     * ERC721 Token ID of the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyTokenId?: string

    /**
     * Internal IMX ID of the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyAssetId?: string

    /**
     * Comma separated string of token addresses of the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyTokenAddress?: string

    /**
     * Token name of the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyTokenName?: string

    /**
     * Min quantity for the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyMinQuantity?: string

    /**
     * Max quantity for the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyMaxQuantity?: string

    /**
     * JSON-encoded metadata filters for the asset this order buys
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly buyMetadata?: string

    /**
     * Token type of the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellTokenType?: string

    /**
     * ERC721 Token ID of the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellTokenId?: string

    /**
     * Internal IMX ID of the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellAssetId?: string

    /**
     * Comma separated string of token addresses of the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellTokenAddress?: string

    /**
     * Token name of the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellTokenName?: string

    /**
     * Min quantity for the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellMinQuantity?: string

    /**
     * Max quantity for the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellMaxQuantity?: string

    /**
     * JSON-encoded metadata filters for the asset this order sells
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly sellMetadata?: string

    /**
     * Comma separated string of fee percentages that are to be paired with auxiliary_fee_recipients
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly auxiliaryFeePercentages?: string

    /**
     * Comma separated string of fee recipients that are to be paired with auxiliary_fee_percentages
     * @type {string}
     * @memberof PublicApiListOrders
     */
    readonly auxiliaryFeeRecipients?: string
}

/**
 * Request parameters for listTokens operation in PublicApi.
 * @export
 * @interface PublicApiListTokensRequest
 */
export interface PublicApiListTokensRequest {
    /**
     * Contract address of the token
     * @type {string}
     * @memberof PublicApiListTokens
     */
    readonly address?: string

    /**
     * Token symbols for the token, e.g. ?symbols&#x3D;IMX,ETH
     * @type {string}
     * @memberof PublicApiListTokens
     */
    readonly symbols?: string
}

/**
 * Request parameters for listTrades operation in PublicApi.
 * @export
 * @interface PublicApiListTradesRequest
 */
export interface PublicApiListTradesRequest {
    /**
     * Party A\&#39;s sell token type
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly partyATokenType?: string

    /**
     * Party A\&#39;s sell token address
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly partyATokenAddress?: string

    /**
     * Party A\&#39;s sell token id
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly partyATokenId?: string

    /**
     * Party B\&#39;s sell token type
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly partyBTokenType?: string

    /**
     * Party B\&#39;s sell token address
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly partyBTokenAddress?: string

    /**
     * Party B\&#39;s sell token id
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly partyBTokenId?: string

    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListTrades
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly direction?: string

    /**
     * Minimum timestamp for this trade
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly minTimestamp?: string

    /**
     * Maximum timestamp for this trade
     * @type {string}
     * @memberof PublicApiListTrades
     */
    readonly maxTimestamp?: string
}

/**
 * Request parameters for listTransfers operation in PublicApi.
 * @export
 * @interface PublicApiListTransfersRequest
 */
export interface PublicApiListTransfersRequest {
    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListTransfers
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly direction?: string

    /**
     * Ethereum address of the user who submitted this transfer
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly user?: string

    /**
     * Status of this transfer
     * @type {'success' | 'failure'}
     * @memberof PublicApiListTransfers
     */
    readonly status?: 'success' | 'failure'

    /**
     * Minimum timestamp for this transfer
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly minTimestamp?: string

    /**
     * Maximum timestamp for this transfer
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly maxTimestamp?: string

    /**
     * Token type of the transferred asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly tokenType?: string

    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly tokenId?: string

    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly assetId?: string

    /**
     * Token address of the transferred asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly tokenAddress?: string

    /**
     * Token name of the transferred asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly tokenName?: string

    /**
     * Max quantity for the transferred asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly minQuantity?: string

    /**
     * Max quantity for the transferred asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly maxQuantity?: string

    /**
     * JSON-encoded metadata filters for the transferred asset
     * @type {string}
     * @memberof PublicApiListTransfers
     */
    readonly metadata?: string
}

/**
 * Request parameters for listWithdrawals operation in PublicApi.
 * @export
 * @interface PublicApiListWithdrawalsRequest
 */
export interface PublicApiListWithdrawalsRequest {
    /**
     * Withdrawal has been transferred to user\&#39;s Layer 1 wallet
     * @type {boolean}
     * @memberof PublicApiListWithdrawals
     */
    readonly withdrawnToWallet?: boolean

    /**
     * Status of the on-chain batch confirmation for this withdrawal
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly rollupStatus?: string

    /**
     * Page size of the result
     * @type {number}
     * @memberof PublicApiListWithdrawals
     */
    readonly pageSize?: number

    /**
     * Cursor
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly cursor?: string

    /**
     * Property to sort by
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly orderBy?: string

    /**
     * Direction to sort (asc/desc)
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly direction?: string

    /**
     * Ethereum address of the user who submitted this withdrawal
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly user?: string

    /**
     * Status of this withdrawal
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly status?: string

    /**
     * Minimum timestamp for this deposit
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly minTimestamp?: string

    /**
     * Maximum timestamp for this deposit
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly maxTimestamp?: string

    /**
     * Token type of the withdrawn asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly tokenType?: string

    /**
     * ERC721 Token ID of the minted asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly tokenId?: string

    /**
     * Internal IMX ID of the minted asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly assetId?: string

    /**
     * Token address of the withdrawn asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly tokenAddress?: string

    /**
     * Token name of the withdrawn asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly tokenName?: string

    /**
     * Min quantity for the withdrawn asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly minQuantity?: string

    /**
     * Max quantity for the withdrawn asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly maxQuantity?: string

    /**
     * JSON-encoded metadata filters for the withdrawn asset
     * @type {string}
     * @memberof PublicApiListWithdrawals
     */
    readonly metadata?: string
}

/**
 * Request parameters for mintTokens operation in PublicApi.
 * @export
 * @interface PublicApiMintTokensRequest
 */
export interface PublicApiMintTokensRequest {
    /**
     * details of tokens to mint
     * @type {Array<MintRequest>}
     * @memberof PublicApiMintTokens
     */
    readonly mintTokensRequestV2: Array<MintRequest>
}

/**
 * Request parameters for registerUser operation in PublicApi.
 * @export
 * @interface PublicApiRegisterUserRequest
 */
export interface PublicApiRegisterUserRequest {
    /**
     * Register User
     * @type {RegisterUserRequestVerifyEth}
     * @memberof PublicApiRegisterUser
     */
    readonly registerUserRequestVerifyEth: RegisterUserRequestVerifyEth
}

/**
 * Request parameters for updateCollection operation in PublicApi.
 * @export
 * @interface PublicApiUpdateCollectionRequest
 */
export interface PublicApiUpdateCollectionRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiUpdateCollection
     */
    readonly address: string

    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiUpdateCollection
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiUpdateCollection
     */
    readonly iMXTimestamp: string

    /**
     * update a collection
     * @type {UpdateCollectionRequest}
     * @memberof PublicApiUpdateCollection
     */
    readonly updateCollectionRequest: UpdateCollectionRequest
}

/**
 * Request parameters for updateMetadataSchemaByName operation in PublicApi.
 * @export
 * @interface PublicApiUpdateMetadataSchemaByNameRequest
 */
export interface PublicApiUpdateMetadataSchemaByNameRequest {
    /**
     * Collection contract address
     * @type {string}
     * @memberof PublicApiUpdateMetadataSchemaByName
     */
    readonly address: string

    /**
     * Metadata schema name
     * @type {string}
     * @memberof PublicApiUpdateMetadataSchemaByName
     */
    readonly name: string

    /**
     * String created by signing wallet address and timestamp
     * @type {string}
     * @memberof PublicApiUpdateMetadataSchemaByName
     */
    readonly iMXSignature: string

    /**
     * Unix Epoc timestamp
     * @type {string}
     * @memberof PublicApiUpdateMetadataSchemaByName
     */
    readonly iMXTimestamp: string

    /**
     * update metadata schema
     * @type {MetadataSchemaRequest}
     * @memberof PublicApiUpdateMetadataSchemaByName
     */
    readonly metadataSchemaRequest: MetadataSchemaRequest
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * Add metadata schema to collection
     * @summary Add metadata schema to collection
     * @param {PublicApiAddMetadataSchemaToCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public addMetadataSchemaToCollection(requestParameters: PublicApiAddMetadataSchemaToCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).addMetadataSchemaToCollection(requestParameters.address, requestParameters.iMXSignature, requestParameters.iMXTimestamp, requestParameters.addMetadataSchemaToCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an order
     * @summary cancel an order
     * @param {PublicApiCancelOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public cancelOrder(requestParameters: PublicApiCancelOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).cancelOrder(requestParameters.id, requestParameters.cancelOrderRequest, requestParameters.xImxEthAddress, requestParameters.xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create collection
     * @summary Create collection
     * @param {PublicApiCreateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createCollection(requestParameters: PublicApiCreateCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createCollection(requestParameters.iMXSignature, requestParameters.iMXTimestamp, requestParameters.createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an order
     * @summary Create an order
     * @param {PublicApiCreateOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createOrder(requestParameters: PublicApiCreateOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createOrder(requestParameters.createOrderRequest, requestParameters.xImxEthAddress, requestParameters.xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a project
     * @summary Create a project
     * @param {PublicApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createProject(requestParameters: PublicApiCreateProjectRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createProject(requestParameters.iMXSignature, requestParameters.iMXTimestamp, requestParameters.createProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Trade
     * @summary Create a Trade between two parties
     * @param {PublicApiCreateTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createTrade(requestParameters: PublicApiCreateTradeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createTrade(requestParameters.createTradeRequest, requestParameters.xImxEthAddress, requestParameters.xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer request
     * @summary Creates a transfer of multiple tokens between two parties
     * @param {PublicApiCreateTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createTransfer(requestParameters: PublicApiCreateTransferRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createTransfer(requestParameters.createTransferRequestV2, requestParameters.xImxEthAddress, requestParameters.xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transfer request
     * @summary Creates a transfer of tokens between two parties
     * @param {PublicApiCreateTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createTransferV1(requestParameters: PublicApiCreateTransferV1Request, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createTransferV1(requestParameters.createTransferRequest, requestParameters.xImxEthAddress, requestParameters.xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a withdrawal
     * @summary Creates a withdrawal of a token
     * @param {PublicApiCreateWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createWithdrawal(requestParameters: PublicApiCreateWithdrawalRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createWithdrawal(requestParameters.createWithdrawalRequest, requestParameters.xImxEthAddress, requestParameters.xImxEthSignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an asset
     * @summary Get details of an asset
     * @param {PublicApiGetAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getAsset(requestParameters: PublicApiGetAssetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getAsset(requestParameters.tokenAddress, requestParameters.tokenId, requestParameters.includeFees, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the token balances of the user
     * @summary Fetches the token balances of the user
     * @param {PublicApiGetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getBalance(requestParameters: PublicApiGetBalanceRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getBalance(requestParameters.owner, requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a collection at the given address
     * @summary Get details of a collection at the given address
     * @param {PublicApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getCollection(requestParameters: PublicApiGetCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getCollection(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a deposit with the given ID
     * @summary Get details of a deposit with the given ID
     * @param {PublicApiGetDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDeposit(requestParameters: PublicApiGetDepositRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDeposit(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get collection metadata schema
     * @summary Get collection metadata schema
     * @param {PublicApiGetMetadataSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getMetadataSchema(requestParameters: PublicApiGetMetadataSchemaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getMetadataSchema(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a mint with the given ID
     * @summary Get details of a mint with the given ID
     * @param {PublicApiGetMintRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getMint(requestParameters: PublicApiGetMintRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getMint(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a mintable token with the given token address and token ID
     * @summary Get details of a mintable token with the given token address and token ID
     * @param {PublicApiGetMintableTokenDetailsByClientTokenIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getMintableTokenDetailsByClientTokenId(requestParameters: PublicApiGetMintableTokenDetailsByClientTokenIdRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getMintableTokenDetailsByClientTokenId(requestParameters.tokenAddress, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an order with the given ID
     * @summary Get details of an order with the given ID
     * @param {PublicApiGetOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getOrder(requestParameters: PublicApiGetOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getOrder(requestParameters.id, requestParameters.includeFees, requestParameters.auxiliaryFeePercentages, requestParameters.auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project
     * @summary Get a project
     * @param {PublicApiGetProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getProject(requestParameters: PublicApiGetProjectRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getProject(requestParameters.id, requestParameters.iMXSignature, requestParameters.iMXTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get projects
     * @summary Get projects
     * @param {PublicApiGetProjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getProjects(requestParameters: PublicApiGetProjectsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getProjects(requestParameters.iMXSignature, requestParameters.iMXTimestamp, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable cancel order
     * @summary Get details a signable cancel order
     * @param {PublicApiGetSignableCancelOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableCancelOrder(requestParameters: PublicApiGetSignableCancelOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableCancelOrder(requestParameters.getSignableCancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable deposit
     * @summary Gets details of a signable deposit
     * @param {PublicApiGetSignableDepositRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableDeposit(requestParameters: PublicApiGetSignableDepositRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableDeposit(requestParameters.getSignableDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable order V3
     * @summary Get details a signable order V3
     * @param {PublicApiGetSignableOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableOrder(requestParameters: PublicApiGetSignableOrderRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableOrder(requestParameters.getSignableOrderRequestV3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get operator signature to allow clients to register the user
     * @summary Get operator signature to allow clients to register the user
     * @param {PublicApiGetSignableRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableRegistration(requestParameters: PublicApiGetSignableRegistrationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableRegistration(requestParameters.getSignableRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details a signable trade V3
     * @summary Get details a signable trade V3
     * @param {PublicApiGetSignableTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableTrade(requestParameters: PublicApiGetSignableTradeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableTrade(requestParameters.getSignableTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets bulk details of a signable transfer
     * @summary Gets bulk details of a signable transfer
     * @param {PublicApiGetSignableTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableTransfer(requestParameters: PublicApiGetSignableTransferRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableTransfer(requestParameters.getSignableTransferRequestV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable transfer
     * @summary Gets details of a signable transfer
     * @param {PublicApiGetSignableTransferV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableTransferV1(requestParameters: PublicApiGetSignableTransferV1Request, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableTransferV1(requestParameters.getSignableTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of a signable withdrawal
     * @summary Gets details of a signable withdrawal
     * @param {PublicApiGetSignableWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSignableWithdrawal(requestParameters: PublicApiGetSignableWithdrawalRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSignableWithdrawal(requestParameters.getSignableWithdrawalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a token
     * @summary Get details of a token
     * @param {PublicApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getToken(requestParameters: PublicApiGetTokenRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getToken(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a trade with the given ID
     * @summary Get details of a trade with the given ID
     * @param {PublicApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getTrade(requestParameters: PublicApiGetTradeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getTrade(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a transfer with the given ID
     * @summary Get details of a transfer with the given ID
     * @param {PublicApiGetTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getTransfer(requestParameters: PublicApiGetTransferRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getTransfer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stark keys for a registered user
     * @summary Get stark keys for a registered user
     * @param {PublicApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUsers(requestParameters: PublicApiGetUsersRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUsers(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets details of withdrawal with the given ID
     * @summary Gets details of withdrawal with the given ID
     * @param {PublicApiGetWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getWithdrawal(requestParameters: PublicApiGetWithdrawalRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getWithdrawal(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of assets
     * @summary Get a list of assets
     * @param {PublicApiListAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listAssets(requestParameters: PublicApiListAssetsRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listAssets(requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.user, requestParameters.status, requestParameters.name, requestParameters.metadata, requestParameters.sellOrders, requestParameters.buyOrders, requestParameters.includeFees, requestParameters.collection, requestParameters.updatedMinTimestamp, requestParameters.updatedMaxTimestamp, requestParameters.auxiliaryFeePercentages, requestParameters.auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of balances for given user
     * @summary Get a list of balances for given user
     * @param {PublicApiListBalancesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listBalances(requestParameters: PublicApiListBalancesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listBalances(requestParameters.owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of collection filters
     * @summary Get a list of collection filters
     * @param {PublicApiListCollectionFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listCollectionFilters(requestParameters: PublicApiListCollectionFiltersRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listCollectionFilters(requestParameters.address, requestParameters.pageSize, requestParameters.nextPageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of collections
     * @summary Get a list of collections
     * @param {PublicApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listCollections(requestParameters: PublicApiListCollectionsRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listCollections(requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.blacklist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of deposits
     * @summary Get a list of deposits
     * @param {PublicApiListDepositsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDeposits(requestParameters: PublicApiListDepositsRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDeposits(requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.user, requestParameters.status, requestParameters.minTimestamp, requestParameters.maxTimestamp, requestParameters.tokenType, requestParameters.tokenId, requestParameters.assetId, requestParameters.tokenAddress, requestParameters.tokenName, requestParameters.minQuantity, requestParameters.maxQuantity, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of mints
     * @summary Get a list of mints
     * @param {PublicApiListMintsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listMints(requestParameters: PublicApiListMintsRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listMints(requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.user, requestParameters.status, requestParameters.minTimestamp, requestParameters.maxTimestamp, requestParameters.tokenType, requestParameters.tokenId, requestParameters.assetId, requestParameters.tokenName, requestParameters.tokenAddress, requestParameters.minQuantity, requestParameters.maxQuantity, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of orders
     * @summary Get a list of orders
     * @param {PublicApiListOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listOrders(requestParameters: PublicApiListOrdersRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listOrders(requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.user, requestParameters.status, requestParameters.minTimestamp, requestParameters.maxTimestamp, requestParameters.updatedMinTimestamp, requestParameters.updatedMaxTimestamp, requestParameters.buyTokenType, requestParameters.buyTokenId, requestParameters.buyAssetId, requestParameters.buyTokenAddress, requestParameters.buyTokenName, requestParameters.buyMinQuantity, requestParameters.buyMaxQuantity, requestParameters.buyMetadata, requestParameters.sellTokenType, requestParameters.sellTokenId, requestParameters.sellAssetId, requestParameters.sellTokenAddress, requestParameters.sellTokenName, requestParameters.sellMinQuantity, requestParameters.sellMaxQuantity, requestParameters.sellMetadata, requestParameters.auxiliaryFeePercentages, requestParameters.auxiliaryFeeRecipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tokens
     * @summary Get a list of tokens
     * @param {PublicApiListTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listTokens(requestParameters: PublicApiListTokensRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listTokens(requestParameters.address, requestParameters.symbols, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of trades
     * @summary Get a list of trades
     * @param {PublicApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listTrades(requestParameters: PublicApiListTradesRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listTrades(requestParameters.partyATokenType, requestParameters.partyATokenAddress, requestParameters.partyATokenId, requestParameters.partyBTokenType, requestParameters.partyBTokenAddress, requestParameters.partyBTokenId, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.minTimestamp, requestParameters.maxTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of transfers
     * @summary Get a list of transfers
     * @param {PublicApiListTransfersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listTransfers(requestParameters: PublicApiListTransfersRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listTransfers(requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.user, requestParameters.status, requestParameters.minTimestamp, requestParameters.maxTimestamp, requestParameters.tokenType, requestParameters.tokenId, requestParameters.assetId, requestParameters.tokenAddress, requestParameters.tokenName, requestParameters.minQuantity, requestParameters.maxQuantity, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of withdrawals
     * @summary Get a list of withdrawals
     * @param {PublicApiListWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWithdrawals(requestParameters: PublicApiListWithdrawalsRequest = {}, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWithdrawals(requestParameters.withdrawnToWallet, requestParameters.rollupStatus, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.user, requestParameters.status, requestParameters.minTimestamp, requestParameters.maxTimestamp, requestParameters.tokenType, requestParameters.tokenId, requestParameters.assetId, requestParameters.tokenAddress, requestParameters.tokenName, requestParameters.minQuantity, requestParameters.maxQuantity, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mint tokens in a batch with fees
     * @summary Mint Tokens V2
     * @param {PublicApiMintTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public mintTokens(requestParameters: PublicApiMintTokensRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).mintTokens(requestParameters.mintTokensRequestV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a user
     * @summary Registers a user
     * @param {PublicApiRegisterUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public registerUser(requestParameters: PublicApiRegisterUserRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).registerUser(requestParameters.registerUserRequestVerifyEth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update collection
     * @summary Update collection
     * @param {PublicApiUpdateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateCollection(requestParameters: PublicApiUpdateCollectionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateCollection(requestParameters.address, requestParameters.iMXSignature, requestParameters.iMXTimestamp, requestParameters.updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update metadata schema by name
     * @summary Update metadata schema by name
     * @param {PublicApiUpdateMetadataSchemaByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateMetadataSchemaByName(requestParameters: PublicApiUpdateMetadataSchemaByNameRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateMetadataSchemaByName(requestParameters.address, requestParameters.name, requestParameters.iMXSignature, requestParameters.iMXTimestamp, requestParameters.metadataSchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
